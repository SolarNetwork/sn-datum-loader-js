{"version":3,"sources":["../src/datumRangeFinder.js","../src/datumLoader.js","../src/jsonClientSupport.js","../src/datumSourceFinder.js","../src/multiLoader.js"],"names":["extractReportableInterval","results","result","repInterval","i","length","undefined","data","endDate","endDateMillis","startDateMillis","startDate","debug","this","_helpers","nodeId","sourceIds","join","datumExtractor","json","success","Array","isArray","pageSizeExtractor","returnedResultCount","startingOffset","totalResults","offsetExtractor","page","max","JsonClientSupport","authBuilder","jsonClient","value","Promise","resolve","reject","load","error","callback","Error","DatumRangeFinder","urlHelpers","defineProperties","_this","NodeDatumUrlHelper","q","queue","client","auth","_step","Symbol","iterator","_iteratorNormalCompletion","_iterator","next","done","urlHelper","url","reportableIntervalUrl","req","on","request","signingKeyValid","reset","snDate","setRequestHeader","HttpHeaders","X_SN_DATE","requestDateHeaderValue","AUTHORIZATION","buildWithSavedKey","defer","get","awaitAll","intervalObj","sDate","Date","eDate","DatumSourceFinder","DatumFilter","datumFilter","addRequest","key","push","requestKeys","filter","nodeIds","metadataFilter","availableSourcesUrl","_step4","_iteratorNormalCompletion4","_iterator4","oneFilter","len","_step2","_iteratorNormalCompletion2","_iterator2","pair","indexOf","sourceId","_step3","_iteratorNormalCompletion3","_iterator3","DatumLoader","publicQuery","_pageSize","_includeTotalResultsCount","_finishedCallback","_urlParameters","_incrementalMode","_concurrency","_queue","_state","_results","isNaN","Number","_typeof","Infinity","loadData","Pagination","args","apply","pagination","queryFilter","withoutTotalResultsCount","offset","listDatumUrl","queryParams","urlQuery","urlQueryEncode","dataArray","handleResults","incMode","_this2","nextOffset","concat","pOffset","withOffset","allResults","map","qJson","forEach","resultArray","MultiLoader","loaders","_loaders","n","loader","bind","call"],"mappings":"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","file":"lib/solarnetwork-datum-loader.min.js.map","sourcesContent":["import { queue } from 'd3-queue';\nimport {\n\tHttpHeaders,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n} from 'solarnetwork-api-core';\n\nimport JsonClientSupport from './jsonClientSupport';\n\n/**\n * @typedef {Object} DatumRange\n * @property {string} timeZone the local time zone of the node\n * @property {number} startDateMillis the start of the time range, in milliseconds since the epoch\n * @property {number} endDateMillis the end of the time range, in milliseconds since the epoch\n * @property {Date} sDate the start of the time range\n * @property {Date} eDate the end of the time range\n */\n\n/**\n * The data callback function.\n * \n * @callback DatumRangeFinder~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {DatumRange} data the result data\n */\n\n/**\n * Class to find the available datum date range for a set of node datum URL helpers.\n * \n * This is useful when generating reports or charts for a set of SolarNode datum streams,\n * so the overall start/end dates can be determined before requesting the actual data.\n * It returns an object starting and ending date related properties, for example:\n * \n * ```\n * {\n *   \"timeZone\":        \"Pacific/Auckland\",\n *   \"sDate\":           Date(1248668709972),\n *   \"startDate\":       \"2009-07-27 16:25\",\n *   \"startDateMillis\": 1248668709972,\n *   \"eDate\":           Date(1379824746781),\n *   \"endDate\":         \"2013-09-22 16:39\",\n *   \"endDateMillis\":   1379824746781\n * }\n * ```\n * @extends {JsonClientSupport}\n * @example\n * // the simple case, for just one SolarNode\n * const urlHelper = new NodeDatumUrlHelper();\n * urlHelper.publicQuery = true;\n * urlHelper.nodeId = 123;\n * urlHelper.sourceIds = ['a', 'b'];\n * const range = await new DatumRangeFinder(urlHelper).fetch();\n * \n * @example\n * // more complex case, for multiple SolarNode / source ID combinations\n * const urlHelper2 = new NodeDatumUrlHelper();\n * urlHelper2.publicQuery = true;\n * urlHelper2.nodeId = 234;\n * urlHelper2.sourceId = 'c';\n * const range2 = await new DatumRangeFinder([urlHelper, urlHelper2]).fetch();\n * \n * @example\n * // with authentication; note the authentication must be valid for all SolarNodes!\n * const auth = new AuthorizationV2Builder('my-token');\n * auth.saveSigningKey('secret');\n * urlHelper.publicQuery = false;\n * urlHelper2.publicQuery = false;\n * const range3 = await new DatumRangeFinder([urlHelper, urlHelper2], auth).fetch();\n */\nclass DatumRangeFinder extends JsonClientSupport {\n    \n    /**\n     * Constructor.\n     * \n     * @param {NodeDatumUrlHelper|NodeDatumUrlHelper[]} urlHelpers the helper(s) to find the avaialble data range for\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried; when provided a pre-signed\n     *                                               key must be available\n     */\n    constructor(urlHelpers, authBuilder) {\n        super(authBuilder);\n        Object.defineProperties(this, {\n            /**\n             * The class version.\n             * \n             * @memberof DatumRangeFinder\n             * @readonly\n             * @type {string}\n             */\n            version: { value: '1.0.0' }\n        });\n\n        /**\n         * @type {NodeDatumUrlHelper[]}\n         * @private\n         */\n        this._helpers = Array.isArray(urlHelpers) ? urlHelpers : urlHelpers ? [urlHelpers] : [new NodeDatumUrlHelper()];\n    }\n\n    /**\n     * Asynchronously find the available datum range using a callback.\n     * \n     * @param {DatumRangeFinder~dataCallback} callback the callback function to invoke\n     * @returns {void}\n     */\n    load(callback) {\n        const q = queue();\n        const jsonClient = this.client();\n        const auth = this.authBuilder;\n        for ( const urlHelper of this._helpers ) {\n            const url = urlHelper.reportableIntervalUrl();\n            const req = jsonClient(url)\n                .on('beforesend', (request) => {\n                    if ( auth && auth.signingKeyValid ) {\n                        auth.reset().snDate(true).url(url);\n                        request.setRequestHeader(HttpHeaders.X_SN_DATE, auth.requestDateHeaderValue);\n                        request.setRequestHeader(HttpHeaders.AUTHORIZATION, auth.buildWithSavedKey());\n                    }\n                });\n            q.defer(req.get, null);\n\t\t}\n        q.awaitAll((error, results) => {\n            if ( error ) {\n                log.error('Error requesting available data range: %s', error);\n                if ( typeof callback === 'function' ) {\n                    callback(error);\n                }\n                return;\n            }\n            var intervalObj = extractReportableInterval(results);\n            if ( intervalObj.startDateMillis !== undefined ) {\n                intervalObj.sDate = new Date(intervalObj.startDateMillis);\n            }\n            if ( intervalObj.endDateMillis !== undefined ) {\n                intervalObj.eDate = new Date(intervalObj.endDateMillis);\n            }\n    \n            if ( typeof callback === 'function' ) {\n                callback(null, intervalObj);\n            }\n        });\n    }\n\n}\n\nfunction extractReportableInterval(results) {\n    var result,\n        i = 0,\n        repInterval;\n    for ( i = 0; i < results.length; i += 1 ) {\n        repInterval = results[i];\n        if ( repInterval.data === undefined || repInterval.data.endDate === undefined ) {\n            log.debug('No data available for %s sources %s',\n                this._helpers[i].nodeId,\n                this._helpers[i].sourceIds.join(','));\n            continue;\n        }\n        repInterval = repInterval.data;\n        if ( result === undefined ) {\n            result = repInterval;\n        } else {\n            // merge start/end dates\n            // note we don't copy the time zone... this breaks when the tz are different!\n            if ( repInterval.endDateMillis > result.endDateMillis ) {\n                result.endDateMillis = repInterval.endDateMillis;\n                result.endDate = repInterval.endDate;\n            }\n            if ( repInterval.startDateMillis < result.startDateMillis ) {\n                result.startDateMillis = repInterval.startDateMillis;\n                result.startDate = repInterval.startDate;\n            }\n        }\n    }\n    return result;\n}\n\nexport default DatumRangeFinder;\n","import {\n\tDatumFilter,\n\tHttpHeaders,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n\tPagination,\n\turlQuery,\n} from 'solarnetwork-api-core';\n\nimport { queue } from 'd3-queue';\nimport JsonClientSupport from './jsonClientSupport';\n\n/**\n * @typedef {Object} Datum\n * @property {string} created the datum date\n * @property {string} sourceId the control ID\n */\n\n/**\n * The data callback function.\n * \n * @callback DatumLoader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Datum[]} data the result data\n * @param {boolean} [done] in incremental mode, will be `true` when invoked on the *last* page of data\n * @param {Pagination} [page] in incremental mode, the page associated with the data\n */\n\n/**\n * Load data for a set of source IDs, date range, and aggregate level using the `listDatumUrl()` endpoint\n * of `NodeDatumUrlHelperMixin`.\n * \n * This object is designed to be used once per query. After creating the object and configuring an\n * asynchronous callback function with {@link DatumLoader#callback}, call {@link DatumLoader#load}\n * to startloading the data. The callback function will be called once all data has been loaded. The\n * callback function can also be passed as an argument to the {@link DatumLoader#load} method directly.\n * \n * @implements {Loader}\n * @extends {JsonClientSupport}\n * @example\n * const filter = new DatumFilter();\n * filter.nodeId = 123;\n * // configure other filter settings here...\n * \n * const urlHelper = new NodeDatumUrlHelper();\n * \n * new DatumLoader(urlHelper, filter).load((error, results) => {\n *   // results is an array of Datum objects\n * });\n * @version 1.1.0\n */\nclass DatumLoader extends JsonClientSupport {\n\n\t/**\n\t * Constructor.\n\t * \n     * @param {NodeDatumUrlHelperMixin} urlHelper a URL helper for accessing node datum via SolarQuery\n\t * @param {DatumFilter} filter the filter parameters to use\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried; when provided a pre-signed\n     *                                               key must be available\n\t */\n    constructor(urlHelper, filter, authBuilder) {\n\t\tsuper(authBuilder);\n        Object.defineProperties(this, {\n                /**\n                 * The class version.\n                 * \n                 * @memberof DatumLoader\n                 * @readonly\n                 * @type {string}\n                 */\n                version: { value: '1.1.0' }\n\t\t});\n\n\t\t/** @type {NodeDatumUrlHelper} */\n\t\tthis.urlHelper = urlHelper || new NodeDatumUrlHelper();\n\t\tif ( !authBuilder ) {\n\t\t\turlHelper.publicQuery = true;\n\t\t}\n\n\t\t/** @type {DatumFilter} */\n\t\tthis.filter = filter || new DatumFilter({\n\t\t\tnodeIds: this.urlHelper.nodeIds,\n\t\t\twithoutTotalResultsCount: true,\n\t\t});\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._pageSize = 1000;\n\n\t\t/**\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._includeTotalResultsCount = false;\n\n        /**\n\t\t * @type {DatumLoader~dataCallback}\n\t\t * @private\n\t\t */\n        this._finishedCallback = undefined;\n\n        /**\n\t\t * @type {object}\n\t\t * @private\n\t\t */\n\t\tthis._urlParameters = undefined;\n\t\t\n\t\t/**\n\t\t * When `true` then call the callback function for every page of data as it becomes available.\n\t\t * Otherwise the callback function will be invoked only after all data has been loaded.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._incrementalMode = false;\n\n\t\t/**\n\t\t * When > 0 then make one request that includes the total result count and first page of\n\t\t * results, followed by parallel requests for the remaining pages.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._concurrency = 0;\n\n\t\t/**\n\t\t * A queue to use for parallel mode, when `concurrency` configured > 0.\n\t\t * @type {queue}\n\t\t * @private\n\t\t */\n\t\tthis._queue = null;\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._state = 0;\n\n\t\t/**\n\t\t * @type {Datum[]}\n\t\t * @private\n\t\t */\n\t\tthis._results = undefined;\n    }\n\n\t/**\n\t * Get or set the concurrency limit to use for parallel requests.\n\t * \n\t * By default requests are not made in parallel (this property is configured as `0`). Change\n\t * to a positive number to enable parallel query mode.\n\t * \n\t * When parallel mode is enabled the loader will make one request that includes \n\t * the total result count and first page of results, followed by parallel requests for any remaining pages\n\t * based on that total result count and configured page size.\n\t * \n\t * @param {number} [value] the concurrency level to use, or `Infinity` for no limit\n\t * @returns {number|DatumLoader} when used as a getter, the current concurrency value, otherwise this object\n\t * @since 1.1.0\n\t */\n\tconcurrency(value) {\n\t\tif ( value === undefined ) { return this._concurrency; }\n\t\tif ( !isNaN(value) && Number(value) > 0 ) {\n\t\t\tthis._concurrency = Number(value);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the callback function, invoked after all data has been loaded. The callback\n\t * function will be passed two arguments: an error and the results. In incremental mode,\n\t * the callback will also be passed a boolean that will be `true` on that last page of data,\n\t * and a `Pagination` that details which page the callback represents.\n\t *\n\t * @param {DatumLoader~dataCallback} [value] the callback function to use\n\t * @returns  {DatumLoader~dataCallback|DatumLoader} when used as a getter, the current callback function, otherwise this object\n\t */\n\tcallback(value) {\n\t\tif ( !value ) { return this._finishedCallback; }\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis._finishedCallback = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set additional URL parameters. The parameters are set as object properties.\n\t * If a property value is an array, multiple parameters for that property will be added.\n\t *\n\t * @param {object} [value] the URL parameters to include with the JSON request\n\t * @returns {object|DatumLoader} when used as a getter, the URL parameters, otherwise this object\n\t */\n    parameters(value) {\n\t\tif ( !value ) return this._urlParameters;\n\t\tif ( typeof value === 'object' ) {\n\t\t\tthis._urlParameters = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set _incremental mode_ for loading the data.\n\t * \n\t * When incremental mode is enabled (set to `true`) then the callback function will be invoked\n\t * for _each result page_ that is loaded. The function will be passed a second `boolean` argument\n\t * that will be set to `true` only on the last page of result data, and a third Pagination`\n\t * object argument that details the starting offset of the page.\n\t * \n\t * When incremental mode is disabled (set to `false`, the default) then all result pages are\n\t * combined into a single array and the callback will be invoked just once.\n\t * \n\t * @param {boolean} [value] the incremental mode to set \n\t * @returns {boolean|DatumLoader} when used a a getter, the incremental mode; otherwise this object\n\t */\n\tincremental(value) {\n\t\tif ( value === undefined ) return this._incrementalMode;\n\t\tthis._incrementalMode = !!value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the result pagination size.\n\t * \n\t * @param {number} [value] the pagination size to set; defaults to `1000`\n\t * @returns {number|DatumLoader} when used as a getter, the pagination size; otherwise this object\n\t */\n\tpaginationSize(value) {\n\t\tif ( isNaN(Number(value)) ) return this._pageSize;\n\t\tthis._pageSize = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the flag for requesting the total results count.\n\t * \n\t * By default the datum loader will _not_ request the overal total result count when querying\n\t * for data, as this speeds up queries. By setting this to `true` the total result count will\n\t * be requested on the _first_ query page.\n\t * \n\t * @param {boolean} [value] the flag to include total results count\n\t * @returns {boolean|DatumLoader} when used a a getter, the total results count inclusion mode; otherwise this object\n\t */\n\tincludeTotalResultsCount(value) {\n\t\tif ( value === undefined ) return this._includeTotalResultsCount;\n\t\tthis._includeTotalResultsCount = !!value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initiate loading the data.\n\t * \n\t * As an alternative to configuring the callback function via the {@link DatumLoader#callback}\n\t * method,a callback function can be passed as an argument to this function. That allows this\n\t * function to be passed to things like `queue.defer`, for example.\n\t *\n\t * @param {DatumLoader~dataCallback} [callback] a callback function to use; either this argument must be provided\n\t *                              or the function must have already been configured via {@link DatumLoader#callback}\n\t * @returns {DatumLoader} this object\n\t */\n\tload(callback) {\n\t\t// to support queue use, allow callback to be passed directly to this function\n\t\tif ( typeof callback === 'function' ) {\n\t\t\tthis._finishedCallback = callback;\n\t\t}\n\t\tthis._state = 1;\n\t\tif ( this._concurrency > 0 ) {\n\t\t\tthis._queue = queue(this._concurrency === Infinity ? null : this._concurrency);\n\t\t}\n\t\tthis.loadData(new Pagination(this._pageSize, 0));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the configured callback function.\n\t * \n\t * @param {Error} [error] an optional  error\n\t * @param {boolean} done `true` if there is no more data to load\n\t * @param {Pagination} [page] the incremental mode page\n\t * @returns {void}\n\t * @private\n\t */\n\thandleResults(error, done, page) {\n\t\tif ( done ) {\n\t\t\tthis._state = 2; // done\n\t\t}\n\n\t\tif ( this._finishedCallback ) {\n\t\t\tlet args = [error, this._results];\n\t\t\tif ( this._incrementalMode ) {\n\t\t\t\targs.push(done);\n\t\t\t\targs.push(page);\n\t\t\t}\n\t\t\tthis._finishedCallback.apply(this, args);\n\t\t}\n\t}\n\n\t/**\n\t * Load a single page of data, starting at a specific offset.\n\t * \n\t * @param {Pagination} [page] the page to load\n\t * @returns {void}\n\t * @private\n\t */\n\tloadData(page) {\n\t\tconst auth = this.authBuilder;\n\t\tconst q = this._queue;\n\t\tlet pagination = (page instanceof Pagination ? page : new Pagination());\n\t\tconst queryFilter = new DatumFilter(this.filter);\n\t\tqueryFilter.withoutTotalResultsCount = ((this._includeTotalResultsCount || q) && pagination.offset === 0 \n\t\t\t? false : true);\n\n\t\tlet url = this.urlHelper.listDatumUrl(queryFilter, undefined, pagination);\n\t\tif ( this._urlParameters ) {\n\t\t\tlet queryParams = urlQuery.urlQueryEncode(this._urlParameters);\n\t\t\tif ( queryParams ) {\n\t\t\t\turl += '&' + queryParams;\n\t\t\t}\n\t\t}\n\t\tconst jsonClient = this.client();\n\t\tconst req = jsonClient(url)\n\t\t\t.on('beforesend', (request) => {\n\t\t\t\tif ( auth && auth.signingKeyValid ) {\n\t\t\t\t\tauth.reset().snDate(true).url(url);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.X_SN_DATE, auth.requestDateHeaderValue);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.AUTHORIZATION, auth.buildWithSavedKey());\n\t\t\t\t}\n\t\t\t}).on('load', (json) => {\n\t\t\t\tlet dataArray = datumExtractor(json);\n\t\t\t\tif ( dataArray === undefined ) {\n\t\t\t\t\tlog.debug('No data available for %s', url);\n\t\t\t\t\tthis.handleResults();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst incMode = this._incrementalMode;\n\t\t\t\tconst nextOffset = offsetExtractor(json, pagination);\n\t\t\t\tconst totalResults = (json.data ? json.data.totalResults : null);\n\n\t\t\t\tif ( this._results === undefined || incMode ) {\n\t\t\t\t\tthis._results = dataArray;\n\t\t\t\t\t\n\t\t\t\t\t// discover page size, if pagination does not already have one\n\t\t\t\t\tif ( pagination.max < 1 ) {\n\t\t\t\t\t\tconst max = pageSizeExtractor(json);\n\t\t\t\t\t\tif ( max > 0 ) {\n\t\t\t\t\t\t\tpagination = new Pagination(max, pagination.offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( incMode ) {\n\t\t\t\t\t\tthis.handleResults(undefined, nextOffset < 1, pagination);\n\t\t\t\t\t}\n\t\t\t\t} else if ( !q ) {\n\t\t\t\t\tthis._results = this._results.concat(dataArray);\n\t\t\t\t}\n\n\t\t\t\t// see if we need to load more results\n\t\t\t\tif ( nextOffset > 0 || (q && pagination.offset > 0) ) {\n\t\t\t\t\tif ( q ) {\n\t\t\t\t\t\tif ( totalResults > 0 ) {\n\t\t\t\t\t\t\t// parallel mode with first page results; queue all remaining pages\n\t\t\t\t\t\t\tfor ( let pOffset = nextOffset; pOffset < totalResults; pOffset += pagination.max ) {\n\t\t\t\t\t\t\t\tthis.loadData(pagination.withOffset(pOffset));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.awaitAll((error, allResults) => {\n\t\t\t\t\t\t\t\tif ( !error ) {\n\t\t\t\t\t\t\t\t\tallResults.map(function(qJson) {\n\t\t\t\t\t\t\t\t\t\treturn datumExtractor(qJson) || [];\n\t\t\t\t\t\t\t\t\t}).forEach(resultArray => {\n\t\t\t\t\t\t\t\t\t\tthis._results = this._results.concat(resultArray);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.handleResults(error !== null ? error : undefined, true);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.loadData(pagination.withOffset(nextOffset));\n\t\t\t\t\t}\n\t\t\t\t} else if ( !incMode ) {\n\t\t\t\t\tthis.handleResults(undefined, true);\n\t\t\t\t}\n\t\t\t}).on('error', (error) => {\n\t\t\t\tlog.error('Error requesting data for %s: %s', url, error);\n\t\t\t\tthis.handleResults(new Error(`Error requesting data for ${url}: ${error}`));\n\t\t\t});\n\t\tif ( q && pagination.offset > 0 ) {\n\t\t\tq.defer(req.get, null);\n\t\t} else {\n\t\t\treq.get();\n\t\t}\n\t}\n\n}\n\n/**\n * Extract the datum list from the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {Datum[]} the extracted data\n * @private\n */\nfunction datumExtractor(json) {\n\tif ( json.success !== true || json.data === undefined || Array.isArray(json.data.results) !== true ) {\n\t\treturn undefined;\n\t}\n\treturn json.data.results;\n}\n\n/**\n * Extract the page size from the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {number} the extracted page size\n * @private\n */\nfunction pageSizeExtractor(json) {\n\tconst data = json.data;\n\treturn (data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t\t? data.returnedResultCount\n\t\t\t: 0);\n}\n\n/**\n * Extract the \"next\" offset to use based on the returned data.\n * \n * If `page` is supplied, then pagination will be based on `page.max` and will continue\n * until less than that many results are returned. If `page` is not supplied, then\n * pagination will be based on `data.returnedResultCount` and will continue until\n * `data.totalResults` has been returned.\n * \n * @param {object} json the JSON results to extract from\n * @param {Pagination} [page] the incremental mode page\n * @returns {number} the extracted offset, or `0` if no more pages to return\n * @private\n */\nfunction offsetExtractor(json, page) {\n\tconst data = json.data;\n\tif ( page && page.max ) {\n\t\t// don't bother with totalResults; just keep going unless returnedResultCount < page.max\n\t\treturn (data.returnedResultCount < page.max\n\t\t\t? 0\n\t\t\t: data.startingOffset + page.max)\n\t}\n\treturn (data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t\t? (data.returnedResultCount + data.startingOffset)\n\t\t\t: 0);\n}\n\nexport default DatumLoader;\n","import { json } from 'd3-request';\n\n/**\n * The data callback function.\n * \n * @callback JsonClientSupport~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {*} data the result data\n */\n\n/**\n * An abstract class with customizable JSON client support.\n * \n * @abstract\n */\nclass JsonClientSupport {\n\n    /**\n\t * Constructor.\n\t * \n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried\n\t */\n    constructor(authBuilder) {\n\n        /**\n         * An authorization builder to use to make authenticated HTTP requests.\n         * @type {AuthorizationV2Builder}\n         * @protected\n         */\n\t\tthis.authBuilder = authBuilder;\n        \n        \n        /**\n         * The JSON client.\n         * @private\n         */\n        this.jsonClient = json;\n    }\n\n\t/**\n\t * Get or set a JSON HTTP client function to use.\n     * \n     * The function must be compatible with `d3.json` and defaults to that. This provides a way\n     * to integrate a different HTTP client if needed, for example a mock implementation in tests.\n\t *\n\t * @param {function} [value] the JSON client function, compatible with `d3.json`\n\t * @returns {function|DatumSourceFinder} when used as a getter, the JSON client function, otherwise this object\n\t */\n\tclient(value) {\n        if ( !value ) return this.jsonClient;\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis.jsonClient = value;\n\t\t}\n\t\treturn this;\n    }\n\n    /**\n     * Asynchronously load the data.\n     * \n     * This method calls {@link JsonClientSupport#load} to perform the actual work.\n     * \n     * @returns {Promise<*>} the result promise\n     */\n    fetch() {\n        return new Promise((resolve, reject) => {\n            this.load((error, results) => {\n                if ( error ) {\n                    reject(error);\n                } else {\n                    resolve(results);\n                }\n            });\n        });\n    }\n\n    /**\n     * Asynchronously load the data using a callback.\n     * \n     * Extending classes must override this method to provide a useful implementation.\n     * \n     * @abstract\n     * @param {JsonClientSupport~dataCallback} callback the callback function to invoke\n     * @returns {void}\n     */\n    load(callback) {\n        callback(new Error('Abstract method must be implemented by subclass.'));\n    }\n}\n\nexport default JsonClientSupport;\n","import { queue } from 'd3-queue';\nimport {\n    DatumFilter,\n\tHttpHeaders,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n} from 'solarnetwork-api-core';\n\nimport JsonClientSupport from './jsonClientSupport';\n\n/**\n * The data callback function.\n * \n * @callback DatumSourceFinder~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {object} data the result data, with node ID keys and `string[]` values representing the source IDs\n */\n\n/**\n * Class to find the available datum sources for a set of node datum URL helpers.\n * \n * This helper is useful for finding what source IDs are avaialble for a set of nodes.\n * It returns an object with node ID properties with associated source ID array values,\n * for example:\n * \n * ```\n * { 123: [\"a\", \"b\", \"c\"] }\n * ```\n * @extends {JsonClientSupport}\n * @example\n * // the simple case, all available sources for just one SolarNode\n * const urlHelper = new NodeDatumUrlHelper();\n * urlHelper.publicQuery = true;\n * urlHelper.nodeId = 123;\n * const sources = await new DatumSourceFinder(urlHelper).fetch();\n * \n * @example\n * // find all sources matching a wildcard pattern within the past day\n * const filter = new DatumFilter();\n * filter.startDate = new Date(Date.now() - 24 * 60 * 60 * 1000);\n * filter.sourceId = '/power/**';\n * const sources2 = await new DatumSourceFinder(urlHelper).filter(filter).fetch();\n * \n * @example\n * // find all sources across multiple SolarNodes\n * const urlHelper2 = new NodeDatumUrlHelper();\n * urlHelper2.publicQuery = true;\n * urlHelper2.nodeId = 234;\n * const sources3 = await new DatumSourceFinder([urlHelper, urlHelper2]).fetch();\n */\nclass DatumSourceFinder extends JsonClientSupport {\n    \n    /**\n     * Constructor.\n     * \n     * @param {NodeDatumUrlHelper|NodeDatumUrlHelper[]} urlHelpers the helper(s) to find the avaialble sources for\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried; when provided a pre-signed\n     *                                               key must be available\n     */\n    constructor(urlHelpers, authBuilder) {\n        super(authBuilder);\n        Object.defineProperties(this, {\n            /**\n             * The class version.\n             * \n             * @memberof DatumSourceFinder\n             * @readonly\n             * @type {string}\n             */\n            version: { value: '1.0.0' }\n        });\n\n        /**\n         * @type {NodeDatumUrlHelper[]}\n         * @private\n         */\n        this._helpers = Array.isArray(urlHelpers) ? urlHelpers : urlHelpers ? [urlHelpers] : [new NodeDatumUrlHelper()];\n    }\n\n\t/**\n\t * Get or set a `DatumFilter` to limit the query with.\n     * \n     * The `startDate`, `endDate`, and `metadataFilter` properties can be used to limit the query scope.\n\t *\n\t * @param {DatumFilter} [value] the datum filter to use\n\t * @returns {function|DatumFilter} when used as a getter, the filter, otherwise this object\n\t */\n\tfilter(value) {\n        if ( !value ) return this.datumFilter;\n\t\tif ( value instanceof DatumFilter ) {\n\t\t\tthis.datumFilter = value;\n\t\t}\n\t\treturn this;\n    }\n\n    /**\n     * Asynchronously find the available datum range using a callback.\n     * \n     * @param {DatumSourceFinder~dataCallback} callback the callback function to invoke\n     * @returns {void}\n     */\n    load(callback) {\n        const q = queue();\n        const jsonClient = this.client();\n        const auth = this.authBuilder;\n        const requestKeys = [];\n\n        function addRequest(key, url) {\n            requestKeys.push(key);\n            const req = jsonClient(url)\n                .on('beforesend', (request) => {\n                    if ( auth && auth.signingKeyValid ) {\n                        auth.reset().snDate(true).url(url);\n                        request.setRequestHeader(HttpHeaders.X_SN_DATE, auth.requestDateHeaderValue);\n                        request.setRequestHeader(HttpHeaders.AUTHORIZATION, auth.buildWithSavedKey());\n                    }\n                });\n            q.defer(req.get, null);\n        }\n        for ( const urlHelper of this._helpers ) {\n            const filter = new DatumFilter(this.datumFilter);\n            filter.nodeIds = urlHelper.nodeIds;\n            if ( filter.metadataFilter || filter.nodeIds.length === 1 ) {\n                // when metadata filter used, multiple node IDs allowed\n                addRequest(this.metadataFilter ? null : filter.nodeId, urlHelper.availableSourcesUrl(filter));\n            } else {\n                // no metadata filter, or multiple node IDs, so add one node ID at a time\n                for ( const nodeId of filter.nodeIds ) {\n                    const oneFilter = new DatumFilter(filter);\n                    oneFilter.nodeId = nodeId;\n                    addRequest(nodeId, urlHelper.availableSourcesUrl(oneFilter));\n                }\n            }\n        }\n        \n        q.awaitAll((error, results) => {\n            if ( error ) {\n                log.error('Error requesting available sources: %s', error);\n                if ( typeof callback === 'function' ) {\n                    callback(error);\n                }\n                return;\n            }\n\n            const result = {};\n\n            for ( let i = 0, len = results.length; i < len; i += 1 ) {\n                const data = (Array.isArray(results[i].data) ? results[i].data : undefined);\n                if ( !data ) {\n                    continue;\n                }\n                const key = requestKeys[i];\n                if ( key === null ) {\n                    // result is array of nodeId/soruceId pairs, e.g. {nodeId:1, sourceId:\"foo\"}\n                    for ( const pair of data ) {\n                        let nodeIds = result[pair.nodeId];\n                        if ( !nodeIds ) {\n                            nodeIds = [];\n                            result[pair.nodeId] = nodeIds;\n                        }\n                        if ( nodeIds.indexOf(pair.sourceId) < 0 ) {\n                            nodeIds.push(pair.sourceId);\n                        }\n                    }\n                } else {\n                    // result is array of sourceIds\n                    let nodeIds = result[key];\n                    if ( !nodeIds ) {\n                        result[key] = data;\n                    } else {\n                        for ( const sourceId of data ) {\n                            if ( nodeIds.indexOf(sourceId) < 0 ) {\n                                nodeIds.push(sourceId);\n                            }\n                        }\n                    }\n                }\n            }\n    \n            if ( typeof callback === 'function' ) {\n                callback(null, result);\n            }\n        });\n    }\n\n}\n\nexport default DatumSourceFinder;\n","import { queue } from 'd3-queue';\n\n/**\n * Interface for classes that can be used to load data for {@link MultiLoader}.\n *\n * @interface Loader\n */\n\n /**\n * The loader callback function.\n * \n * @callback Loader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Object} data the result data\n */\n\n/**\n * Load data asynchronously with a callback.\n *\n * @function\n * @name Loader#load\n * @param {Loader~dataCallback} callback the callback to invoke with the results\n * @returns {Loader} the loader object\n */\n\n/**\n * The data callback function.\n * \n * @callback MultiLoader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Object[]} data the result data from all loaders\n */\n\n/**\n * Load data from multiple {@link Loader} objects, invoking a callback function\n * after all data has been loaded. Call {@link MultiLoader#load} to start loading the data.\n * \n * The {@link DatumLoader} class conforms to the {@link Loader} interface, so can be used to\n * load arrays of {@link Datum} objects based on search criteria.\n * \n * @example\n * const filter1 = new DatumFilter();\n * filter1.nodeId = 123;\n * // configure other filter settings here...\n * \n * const filter2 = new DatumFilter();\n * filter2.nodeId = 234;\n * // configure other filter settings here\n * \n * const urlHelper = new NodeDatumUrlHelper();\n * \n * new MultiLoader([\n *   new DatumLoader(urlHelper, filter1),\n *   new DatumLoader(urlHelper, filter2),\n * ]).load((error, results) => {\n *   // results is a 2-element array of Datum arrays\n * });\n * \n * @version 1.1.0\n */\nclass MultiLoader {\n    \n\t/**\n\t * Constructor.\n\t *\n\t * @param {Loader[]} loaders - array of loader objects\n\t */\n    constructor(loaders) {\n        Object.defineProperties(this, {\n                /**\n                 * The class version.\n                 * \n                 * @memberof MultiLoader\n                 * @readonly\n                 * @type {string}\n                 */\n                version: { value: '1.1.0' }\n\t\t});\n\n\t\t/**\n\t\t * @type {Loader[]}\n\t\t * @private\n\t\t */\n\t\tthis._loaders = loaders;\n\t\t\n\t\t/**\n\t\t * @type {MultiLoader~dataCallback}\n\t\t * @private\n\t\t */\n\t\tthis._finishedCallback = undefined;\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._concurrency = Infinity;\n\t}\n\t\n\t/**\n\t * Get or set the concurrency limit to use for requets.\n\t * \n\t * A default, infinite concurrency queue will be used by default.\n\t * \n\t * @param {number} [value] the concurrency level to use, or `Infinity` for no limit\n\t * @returns {number|MultiLoader} when used as a getter, the current concurrency value, otherwise this object\n\t * @since 1.1.0\n\t */\n\tconcurrency(value) {\n\t\tif ( value === undefined ) { return this._concurrency; }\n\t\tvar n = Number(value);\n\t\tif ( !isNaN(value) && n > 0 ) {\n\t\t\tthis._concurrency = n;\n\t\t}\n\t\treturn this;\n\t}\n\n    /**\n     * Asynchronously load the data.\n     * \n     * This method calls {@link MultiLoader#load} to perform the actual work.\n     * \n     * @returns {Promise<Object[]>} the result promise\n     */\n    fetch() {\n        return new Promise((resolve, reject) => {\n            this.load((error, results) => {\n                if ( error ) {\n                    reject(error);\n                } else {\n                    resolve(results);\n                }\n            });\n        });\n    }\n\n\t/**\n\t * Initiate loading the data. This will call {@link Loader#load} on each\n\t * supplied loader, in parallel. As an alternative to configuring the callback function via\n\t * the {@link MultiLoader#callback} method, a callback function can be passed as an argument\n\t * to this function. This allows this function to be passed to `queue.defer`, for example.\n\t *\n\t * @param {MultiLoader~dataCallback} [callback] a callback function to use; either this argument must be provided\n\t *                              or the function must have already been configured via  {@link MultiLoader#callback}\n\t * @returns {MultiLoader} this object\n\t */\n\tload(callback) {\n\t\t// to support queue use, allow callback to be passed directly to this function\n\t\tif ( typeof callback === 'function' ) {\n\t\t\tthis._finishedCallback = callback;\n\t\t}\n\t\tconst q = queue(this._concurrency);\n\t\tthis._loaders.forEach((loader) => {\n\t\t\t// queue.defer will invoke the callback with a `null` `this` object, so `e.load.bind` here\n\t\t\tq.defer(loader.load.bind(loader));\n\t\t});\n\t\tq.awaitAll((error, results) => {\n\t\t\tif ( this._finishedCallback ) {\n\t\t\t\tthis._finishedCallback.call(this, error, results);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the callback function, invoked after all data has been loaded. The callback\n\t * function will be passed two arguments: an error and the results as an array of results\n\t * from each configured {@link Loader}.\n\t *\n\t * @param {MultiLoader~dataCallback} [value] the callback function to use\n\t * @returns  {MultiLoader~dataCallback|MultiLoader} when used as a getter, the current callback function, otherwise this object\n\t */\n\tcallback(value) {\n\t\tif ( !value ) { return this._finishedCallback; }\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis._finishedCallback = value;\n\t\t}\n\t\treturn this;\n\t}\n\n}\n\nexport default MultiLoader;\n"]}