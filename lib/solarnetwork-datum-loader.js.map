{"version":3,"file":"solarnetwork-datum-loader.js","sources":["../src/jsonClientSupport.js","../src/datumRangeFinder.js","../src/datumSourceFinder.js","../src/datumLoader.js","../src/multiLoader.js"],"sourcesContent":["import { json } from \"d3-request\";\n\n/**\n * The data callback function.\n *\n * @callback JsonClientSupport~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {*} data the result data\n */\n\n/**\n * An abstract class with customizable JSON client support.\n *\n * @abstract\n */\nclass JsonClientSupport {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried\n\t */\n\tconstructor(authBuilder) {\n\t\t/**\n\t\t * An authorization builder to use to make authenticated HTTP requests.\n\t\t * @type {AuthorizationV2Builder}\n\t\t * @protected\n\t\t */\n\t\tthis.authBuilder = authBuilder;\n\n\t\t/**\n\t\t * The JSON client.\n\t\t * @private\n\t\t */\n\t\tthis.jsonClient = json;\n\t}\n\n\t/**\n\t * Get or set a JSON HTTP client function to use.\n\t *\n\t * The function must be compatible with `d3.json` and defaults to that. This provides a way\n\t * to integrate a different HTTP client if needed, for example a mock implementation in tests.\n\t *\n\t * @param {function} [value] the JSON client function, compatible with `d3.json`\n\t * @returns {function|DatumSourceFinder} when used as a getter, the JSON client function, otherwise this object\n\t */\n\tclient(value) {\n\t\tif (!value) return this.jsonClient;\n\t\tif (typeof value === \"function\") {\n\t\t\tthis.jsonClient = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Asynchronously load the data.\n\t *\n\t * This method calls {@link JsonClientSupport#load} to perform the actual work.\n\t *\n\t * @returns {Promise<*>} the result promise\n\t */\n\tfetch() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.load((error, results) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Asynchronously load the data using a callback.\n\t *\n\t * Extending classes must override this method to provide a useful implementation.\n\t *\n\t * @abstract\n\t * @param {JsonClientSupport~dataCallback} callback the callback function to invoke\n\t * @returns {void}\n\t */\n\tload(callback) {\n\t\tcallback(new Error(\"Abstract method must be implemented by subclass.\"));\n\t}\n}\n\nexport default JsonClientSupport;\n","import { queue } from \"d3-queue\";\nimport { HttpHeaders, Logger as log, NodeDatumUrlHelper } from \"solarnetwork-api-core\";\n\nimport JsonClientSupport from \"./jsonClientSupport\";\n\n/**\n * @typedef {Object} DatumRange\n * @property {string} timeZone the local time zone of the node\n * @property {number} startDateMillis the start of the time range, in milliseconds since the epoch\n * @property {number} endDateMillis the end of the time range, in milliseconds since the epoch\n * @property {Date} sDate the start of the time range\n * @property {Date} eDate the end of the time range\n */\n\n/**\n * The data callback function.\n *\n * @callback DatumRangeFinder~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {DatumRange} data the result data\n */\n\n/**\n * Class to find the available datum date range for a set of node datum URL helpers.\n *\n * This is useful when generating reports or charts for a set of SolarNode datum streams,\n * so the overall start/end dates can be determined before requesting the actual data.\n * It returns an object starting and ending date related properties, for example:\n *\n * ```\n * {\n *   \"timeZone\":        \"Pacific/Auckland\",\n *   \"sDate\":           Date(1248668709972),\n *   \"startDate\":       \"2009-07-27 16:25\",\n *   \"startDateMillis\": 1248668709972,\n *   \"eDate\":           Date(1379824746781),\n *   \"endDate\":         \"2013-09-22 16:39\",\n *   \"endDateMillis\":   1379824746781\n * }\n * ```\n * @extends {JsonClientSupport}\n * @example\n * // the simple case, for just one SolarNode\n * const urlHelper = new NodeDatumUrlHelper();\n * urlHelper.publicQuery = true;\n * urlHelper.nodeId = 123;\n * urlHelper.sourceIds = ['a', 'b'];\n * const range = await new DatumRangeFinder(urlHelper).fetch();\n *\n * @example\n * // more complex case, for multiple SolarNode / source ID combinations\n * const urlHelper2 = new NodeDatumUrlHelper();\n * urlHelper2.publicQuery = true;\n * urlHelper2.nodeId = 234;\n * urlHelper2.sourceId = 'c';\n * const range2 = await new DatumRangeFinder([urlHelper, urlHelper2]).fetch();\n *\n * @example\n * // with authentication; note the authentication must be valid for all SolarNodes!\n * const auth = new AuthorizationV2Builder('my-token');\n * auth.saveSigningKey('secret');\n * urlHelper.publicQuery = false;\n * urlHelper2.publicQuery = false;\n * const range3 = await new DatumRangeFinder([urlHelper, urlHelper2], auth).fetch();\n */\nclass DatumRangeFinder extends JsonClientSupport {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {NodeDatumUrlHelper|NodeDatumUrlHelper[]} urlHelpers the helper(s) to find the avaialble data range for\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried; when provided a pre-signed\n\t *                                               key must be available\n\t */\n\tconstructor(urlHelpers, authBuilder) {\n\t\tsuper(authBuilder);\n\t\tObject.defineProperties(this, {\n\t\t\t/**\n\t\t\t * The class version.\n\t\t\t *\n\t\t\t * @memberof DatumRangeFinder\n\t\t\t * @readonly\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tversion: { value: \"1.0.0\" }\n\t\t});\n\n\t\t/**\n\t\t * @type {NodeDatumUrlHelper[]}\n\t\t * @private\n\t\t */\n\t\tthis._helpers = Array.isArray(urlHelpers)\n\t\t\t? urlHelpers\n\t\t\t: urlHelpers\n\t\t\t? [urlHelpers]\n\t\t\t: [new NodeDatumUrlHelper()];\n\t}\n\n\t/**\n\t * Asynchronously find the available datum range using a callback.\n\t *\n\t * @param {DatumRangeFinder~dataCallback} callback the callback function to invoke\n\t * @returns {void}\n\t */\n\tload(callback) {\n\t\tconst q = queue();\n\t\tconst jsonClient = this.client();\n\t\tconst auth = this.authBuilder;\n\t\tfor (const urlHelper of this._helpers) {\n\t\t\tconst url = urlHelper.reportableIntervalUrl();\n\t\t\tconst req = jsonClient(url).on(\"beforesend\", request => {\n\t\t\t\tif (auth && auth.signingKeyValid) {\n\t\t\t\t\tauth.reset()\n\t\t\t\t\t\t.snDate(true)\n\t\t\t\t\t\t.url(url, true);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.X_SN_DATE, auth.requestDateHeaderValue);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.AUTHORIZATION, auth.buildWithSavedKey());\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.defer(req.get, null);\n\t\t}\n\t\tq.awaitAll((error, results) => {\n\t\t\tif (error) {\n\t\t\t\tlog.error(\"Error requesting available data range: %s\", error);\n\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\tcallback(error);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar intervalObj = extractReportableInterval(results);\n\t\t\tif (intervalObj.startDateMillis !== undefined) {\n\t\t\t\tintervalObj.sDate = new Date(intervalObj.startDateMillis);\n\t\t\t}\n\t\t\tif (intervalObj.endDateMillis !== undefined) {\n\t\t\t\tintervalObj.eDate = new Date(intervalObj.endDateMillis);\n\t\t\t}\n\n\t\t\tif (typeof callback === \"function\") {\n\t\t\t\tcallback(null, intervalObj);\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction extractReportableInterval(results) {\n\tvar result,\n\t\ti = 0,\n\t\trepInterval;\n\tfor (i = 0; i < results.length; i += 1) {\n\t\trepInterval = results[i];\n\t\tif (repInterval.data === undefined || repInterval.data.endDate === undefined) {\n\t\t\tlog.debug(\n\t\t\t\t\"No data available for %s sources %s\",\n\t\t\t\tthis._helpers[i].nodeId,\n\t\t\t\tthis._helpers[i].sourceIds.join(\",\")\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\t\trepInterval = repInterval.data;\n\t\tif (result === undefined) {\n\t\t\tresult = repInterval;\n\t\t} else {\n\t\t\t// merge start/end dates\n\t\t\t// note we don't copy the time zone... this breaks when the tz are different!\n\t\t\tif (repInterval.endDateMillis > result.endDateMillis) {\n\t\t\t\tresult.endDateMillis = repInterval.endDateMillis;\n\t\t\t\tresult.endDate = repInterval.endDate;\n\t\t\t}\n\t\t\tif (repInterval.startDateMillis < result.startDateMillis) {\n\t\t\t\tresult.startDateMillis = repInterval.startDateMillis;\n\t\t\t\tresult.startDate = repInterval.startDate;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport default DatumRangeFinder;\n","import { queue } from \"d3-queue\";\nimport { DatumFilter, HttpHeaders, Logger as log, NodeDatumUrlHelper } from \"solarnetwork-api-core\";\n\nimport JsonClientSupport from \"./jsonClientSupport\";\n\n/**\n * The data callback function.\n *\n * @callback DatumSourceFinder~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {object} data the result data, with node ID keys and `string[]` values representing the source IDs\n */\n\n/**\n * Class to find the available datum sources for a set of node datum URL helpers.\n *\n * This helper is useful for finding what source IDs are avaialble for a set of nodes.\n * It returns an object with node ID properties with associated source ID array values,\n * for example:\n *\n * ```\n * { 123: [\"a\", \"b\", \"c\"] }\n * ```\n * @extends {JsonClientSupport}\n * @example\n * // the simple case, all available sources for just one SolarNode\n * const urlHelper = new NodeDatumUrlHelper();\n * urlHelper.publicQuery = true;\n * urlHelper.nodeId = 123;\n * const sources = await new DatumSourceFinder(urlHelper).fetch();\n *\n * @example\n * // find all sources matching a wildcard pattern within the past day\n * const filter = new DatumFilter();\n * filter.startDate = new Date(Date.now() - 24 * 60 * 60 * 1000);\n * filter.sourceId = '/power/**';\n * const sources2 = await new DatumSourceFinder(urlHelper).filter(filter).fetch();\n *\n * @example\n * // find all sources across multiple SolarNodes\n * const urlHelper2 = new NodeDatumUrlHelper();\n * urlHelper2.publicQuery = true;\n * urlHelper2.nodeId = 234;\n * const sources3 = await new DatumSourceFinder([urlHelper, urlHelper2]).fetch();\n */\nclass DatumSourceFinder extends JsonClientSupport {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {NodeDatumUrlHelper|NodeDatumUrlHelper[]} urlHelpers the helper(s) to find the avaialble sources for\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried; when provided a pre-signed\n\t *                                               key must be available\n\t */\n\tconstructor(urlHelpers, authBuilder) {\n\t\tsuper(authBuilder);\n\t\tObject.defineProperties(this, {\n\t\t\t/**\n\t\t\t * The class version.\n\t\t\t *\n\t\t\t * @memberof DatumSourceFinder\n\t\t\t * @readonly\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tversion: { value: \"1.0.0\" }\n\t\t});\n\n\t\t/**\n\t\t * @type {NodeDatumUrlHelper[]}\n\t\t * @private\n\t\t */\n\t\tthis._helpers = Array.isArray(urlHelpers)\n\t\t\t? urlHelpers\n\t\t\t: urlHelpers\n\t\t\t? [urlHelpers]\n\t\t\t: [new NodeDatumUrlHelper()];\n\t}\n\n\t/**\n\t * Get or set a `DatumFilter` to limit the query with.\n\t *\n\t * The `startDate`, `endDate`, and `metadataFilter` properties can be used to limit the query scope.\n\t *\n\t * @param {DatumFilter} [value] the datum filter to use\n\t * @returns {function|DatumFilter} when used as a getter, the filter, otherwise this object\n\t */\n\tfilter(value) {\n\t\tif (!value) return this.datumFilter;\n\t\tif (value instanceof DatumFilter) {\n\t\t\tthis.datumFilter = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Asynchronously find the available datum range using a callback.\n\t *\n\t * @param {DatumSourceFinder~dataCallback} callback the callback function to invoke\n\t * @returns {void}\n\t */\n\tload(callback) {\n\t\tconst q = queue();\n\t\tconst jsonClient = this.client();\n\t\tconst auth = this.authBuilder;\n\t\tconst requestKeys = [];\n\n\t\tfunction addRequest(key, url) {\n\t\t\trequestKeys.push(key);\n\t\t\tconst req = jsonClient(url).on(\"beforesend\", request => {\n\t\t\t\tif (auth && auth.signingKeyValid) {\n\t\t\t\t\tauth.reset()\n\t\t\t\t\t\t.snDate(true)\n\t\t\t\t\t\t.url(url, true);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.X_SN_DATE, auth.requestDateHeaderValue);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.AUTHORIZATION, auth.buildWithSavedKey());\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.defer(req.get, null);\n\t\t}\n\t\tfor (const urlHelper of this._helpers) {\n\t\t\tconst filter = new DatumFilter(this.datumFilter);\n\t\t\tfilter.nodeIds = urlHelper.nodeIds;\n\t\t\tif (filter.metadataFilter || filter.nodeIds.length === 1) {\n\t\t\t\t// when metadata filter used, multiple node IDs allowed\n\t\t\t\taddRequest(\n\t\t\t\t\tthis.metadataFilter ? null : filter.nodeId,\n\t\t\t\t\turlHelper.availableSourcesUrl(filter)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t// no metadata filter, or multiple node IDs, so add one node ID at a time\n\t\t\t\tfor (const nodeId of filter.nodeIds) {\n\t\t\t\t\tconst oneFilter = new DatumFilter(filter);\n\t\t\t\t\toneFilter.nodeId = nodeId;\n\t\t\t\t\taddRequest(nodeId, urlHelper.availableSourcesUrl(oneFilter));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tq.awaitAll((error, results) => {\n\t\t\tif (error) {\n\t\t\t\tlog.error(\"Error requesting available sources: %s\", error);\n\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\tcallback(error);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst result = {};\n\n\t\t\tfor (let i = 0, len = results.length; i < len; i += 1) {\n\t\t\t\tconst data = Array.isArray(results[i].data) ? results[i].data : undefined;\n\t\t\t\tif (!data) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst key = requestKeys[i];\n\t\t\t\tif (key === null) {\n\t\t\t\t\t// result is array of nodeId/soruceId pairs, e.g. {nodeId:1, sourceId:\"foo\"}\n\t\t\t\t\tfor (const pair of data) {\n\t\t\t\t\t\tlet nodeIds = result[pair.nodeId];\n\t\t\t\t\t\tif (!nodeIds) {\n\t\t\t\t\t\t\tnodeIds = [];\n\t\t\t\t\t\t\tresult[pair.nodeId] = nodeIds;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (nodeIds.indexOf(pair.sourceId) < 0) {\n\t\t\t\t\t\t\tnodeIds.push(pair.sourceId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// result is array of sourceIds\n\t\t\t\t\tlet nodeIds = result[key];\n\t\t\t\t\tif (!nodeIds) {\n\t\t\t\t\t\tresult[key] = data;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const sourceId of data) {\n\t\t\t\t\t\t\tif (nodeIds.indexOf(sourceId) < 0) {\n\t\t\t\t\t\t\t\tnodeIds.push(sourceId);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof callback === \"function\") {\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport default DatumSourceFinder;\n","import {\n\tDatumFilter,\n\tDatumReadingTypes,\n\tHttpHeaders,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n\tPagination,\n\turlQuery\n} from \"solarnetwork-api-core\";\n\nimport { queue } from \"d3-queue\";\nimport JsonClientSupport from \"./jsonClientSupport\";\n\n/**\n * @typedef {Object} Datum\n * @property {string} created the datum date\n * @property {string} sourceId the control ID\n */\n\n/**\n * The data callback function.\n *\n * @callback DatumLoader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Datum[]} data the result data\n * @param {boolean} [done] in incremental mode, will be `true` when invoked on the *last* page of data\n * @param {Pagination} [page] in incremental mode, the page associated with the data\n */\n\n/**\n * Load data for a set of source IDs, date range, and aggregate level using either the `listDatumUrl()`\n * or `datumReadingUrl()` URLs of `NodeDatumUrlHelperMixin` (the `/datum/list` or `/datum/reading`\n * endpoints).\n *\n * This object is designed to be used once per query. After creating the object and configuring an\n * asynchronous callback function with {@link DatumLoader#callback}, call {@link DatumLoader#load}\n * to start loading the data. The callback function will be called once all data has been loaded. The\n * callback function can also be passed as an argument to the {@link DatumLoader#load} method directly.\n *\n * @implements {Loader}\n * @extends {JsonClientSupport}\n * @example\n * const filter = new DatumFilter();\n * filter.nodeId = 123;\n * // configure other filter settings here...\n *\n * const urlHelper = new NodeDatumUrlHelper();\n *\n * new DatumLoader(urlHelper, filter).load((error, results) => {\n *   // results is an array of Datum objects\n * });\n * @version 1.2.0\n */\nclass DatumLoader extends JsonClientSupport {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {NodeDatumUrlHelperMixin} urlHelper a URL helper for accessing node datum via SolarQuery\n\t * @param {DatumFilter} filter the filter parameters to use\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried; when provided a pre-signed\n\t *                                               key must be available\n\t */\n\tconstructor(urlHelper, filter, authBuilder) {\n\t\tsuper(authBuilder);\n\t\tObject.defineProperties(this, {\n\t\t\t/**\n\t\t\t * The class version.\n\t\t\t *\n\t\t\t * @memberof DatumLoader\n\t\t\t * @readonly\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tversion: { value: \"1.2.0\" }\n\t\t});\n\n\t\t/** @type {NodeDatumUrlHelper} */\n\t\tthis.urlHelper = urlHelper || new NodeDatumUrlHelper();\n\t\tif (!authBuilder) {\n\t\t\turlHelper.publicQuery = true;\n\t\t}\n\n\t\t/** @type {DatumFilter} */\n\t\tthis.filter =\n\t\t\tfilter ||\n\t\t\tnew DatumFilter({\n\t\t\t\tnodeIds: this.urlHelper.nodeIds,\n\t\t\t\twithoutTotalResultsCount: true\n\t\t\t});\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._pageSize = 1000;\n\n\t\t/**\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._includeTotalResultsCount = false;\n\n\t\t/**\n\t\t * @type {DatumLoader~dataCallback}\n\t\t * @private\n\t\t */\n\t\tthis._finishedCallback = undefined;\n\n\t\t/**\n\t\t * @type {object}\n\t\t * @private\n\t\t */\n\t\tthis._urlParameters = undefined;\n\n\t\t/**\n\t\t * When `true` then call the callback function for every page of data as it becomes available.\n\t\t * Otherwise the callback function will be invoked only after all data has been loaded.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._incrementalMode = false;\n\n\t\t/**\n\t\t * When `true` then invoke the `/datum/reading` endpoint to load data, otherwise use `/datum/list`.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._readingsMode = false;\n\n\t\t/**\n\t\t * An optional proxy URL to use instead of the host returned by the configured `NodeDatumUrlHelperMixin`.\n\t\t * This should be configured as an absolute URL to the proxy target, e.g. `https://query.solarnetwork.net/1m`.\n\t\t * @type {string}\n\t\t * @private\n\t\t */\n\t\tthis._proxyUrl = undefined;\n\n\t\t/**\n\t\t * When > 0 then make one request that includes the total result count and first page of\n\t\t * results, followed by parallel requests for the remaining pages.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._concurrency = 0;\n\n\t\t/**\n\t\t * A queue to use for parallel mode, when `concurrency` configured > 0.\n\t\t * @type {queue}\n\t\t * @private\n\t\t */\n\t\tthis._queue = null;\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._state = 0;\n\n\t\t/**\n\t\t * @type {Datum[]}\n\t\t * @private\n\t\t */\n\t\tthis._results = undefined;\n\t}\n\n\t/**\n\t * Get or set the concurrency limit to use for parallel requests.\n\t *\n\t * By default requests are not made in parallel (this property is configured as `0`). Change\n\t * to a positive number to enable parallel query mode.\n\t *\n\t * When parallel mode is enabled the loader will make one request that includes\n\t * the total result count and first page of results, followed by parallel requests for any remaining pages\n\t * based on that total result count and configured page size.\n\t *\n\t * @param {number} [value] the concurrency level to use, or `Infinity` for no limit\n\t * @returns {number|DatumLoader} when used as a getter, the current concurrency value, otherwise this object\n\t * @since 1.1.0\n\t */\n\tconcurrency(value) {\n\t\tif (value === undefined) {\n\t\t\treturn this._concurrency;\n\t\t}\n\t\tif (!isNaN(value) && Number(value) > 0) {\n\t\t\tthis._concurrency = Number(value);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the callback function, invoked after all data has been loaded. The callback\n\t * function will be passed two arguments: an error and the results. In incremental mode,\n\t * the callback will also be passed a boolean that will be `true` on that last page of data,\n\t * and a `Pagination` that details which page the callback represents.\n\t *\n\t * @param {DatumLoader~dataCallback} [value] the callback function to use\n\t * @returns  {DatumLoader~dataCallback|DatumLoader} when used as a getter, the current callback function, otherwise this object\n\t */\n\tcallback(value) {\n\t\tif (!value) {\n\t\t\treturn this._finishedCallback;\n\t\t}\n\t\tif (typeof value === \"function\") {\n\t\t\tthis._finishedCallback = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set additional URL parameters. The parameters are set as object properties.\n\t * If a property value is an array, multiple parameters for that property will be added.\n\t *\n\t * @param {object} [value] the URL parameters to include with the JSON request\n\t * @returns {object|DatumLoader} when used as a getter, the URL parameters, otherwise this object\n\t */\n\tparameters(value) {\n\t\tif (!value) return this._urlParameters;\n\t\tif (typeof value === \"object\") {\n\t\t\tthis._urlParameters = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set _incremental mode_ for loading the data.\n\t *\n\t * When incremental mode is enabled (set to `true`) then the callback function will be invoked\n\t * for _each result page_ that is loaded. The function will be passed a second `boolean` argument\n\t * that will be set to `true` only on the last page of result data, and a third Pagination`\n\t * object argument that details the starting offset of the page.\n\t *\n\t * When incremental mode is disabled (set to `false`, the default) then all result pages are\n\t * combined into a single array and the callback will be invoked just once.\n\t *\n\t * @param {boolean} [value] the incremental mode to set\n\t * @returns {boolean|DatumLoader} when used a a getter, the incremental mode; otherwise this object\n\t */\n\tincremental(value) {\n\t\tif (value === undefined) return this._incrementalMode;\n\t\tthis._incrementalMode = !!value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the result pagination size.\n\t *\n\t * @param {number} [value] the pagination size to set; defaults to `1000`\n\t * @returns {number|DatumLoader} when used as a getter, the pagination size; otherwise this object\n\t */\n\tpaginationSize(value) {\n\t\tif (isNaN(Number(value))) return this._pageSize;\n\t\tthis._pageSize = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the flag for requesting the total results count.\n\t *\n\t * By default the datum loader will _not_ request the overal total result count when querying\n\t * for data, as this speeds up queries. By setting this to `true` the total result count will\n\t * be requested on the _first_ query page.\n\t *\n\t * @param {boolean} [value] the flag to include total results count\n\t * @returns {boolean|DatumLoader} when used a a getter, the total results count inclusion mode; otherwise this object\n\t */\n\tincludeTotalResultsCount(value) {\n\t\tif (value === undefined) return this._includeTotalResultsCount;\n\t\tthis._includeTotalResultsCount = !!value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set _readings mode_ for loading the data.\n\t *\n\t * When readings mode is enabled (set to `true`) then the `/datum/reading` endpoint will be invoked\n\t * to load data.\n\t *\n\t * When readings mode is disabled (set to `false`, the default) then the `/datum/list` endpoint will\n\t * be invoked to load data.\n\t *\n\t * @param {boolean} [value] the readings mode to set\n\t * @returns {boolean|DatumLoader} when used a a getter, the readings mode; otherwise this object\n\t */\n\treadings(value) {\n\t\tif (value === undefined) return this._readingsMode;\n\t\tthis._readingsMode = !!value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the URL to a proxy to use for loading the data.\n\t *\n\t * This can be configured as an absolute URL to the proxy server to use instead of making requests\n\t * directly to the URL returned by the configured `NodeDatumUrlHelperMixin`. For example:\n\t *\n\t * * https://query.solarnetwork.net\n\t * * https://query.solarnetwork.net/1m\n\t *\n\t * @param {string} [value] the proxy URL to set, or `null` or an empty string to not use any proxy\n\t * @returns {string|DatumLoader} when used a a getter, the readings mode; otherwise this object\n\t */\n\tproxyUrl(value) {\n\t\tif (value === undefined) return this._proxyUrl;\n\t\tthis._proxyUrl = value ? value : undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initiate loading the data.\n\t *\n\t * As an alternative to configuring the callback function via the {@link DatumLoader#callback}\n\t * method,a callback function can be passed as an argument to this function. That allows this\n\t * function to be passed to things like `queue.defer`, for example.\n\t *\n\t * @param {DatumLoader~dataCallback} [callback] a callback function to use; either this argument must be provided\n\t *                              or the function must have already been configured via {@link DatumLoader#callback}\n\t * @returns {DatumLoader} this object\n\t */\n\tload(callback) {\n\t\t// to support queue use, allow callback to be passed directly to this function\n\t\tif (typeof callback === \"function\") {\n\t\t\tthis._finishedCallback = callback;\n\t\t}\n\t\tthis._state = 1;\n\t\tif (this._concurrency > 0) {\n\t\t\tthis._queue = queue(this._concurrency === Infinity ? null : this._concurrency);\n\t\t}\n\t\tthis.loadData(new Pagination(this._pageSize, 0));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the configured callback function.\n\t *\n\t * @param {Error} [error] an optional  error\n\t * @param {boolean} done `true` if there is no more data to load\n\t * @param {Pagination} [page] the incremental mode page\n\t * @returns {void}\n\t * @private\n\t */\n\thandleResults(error, done, page) {\n\t\tif (done) {\n\t\t\tthis._state = 2; // done\n\t\t}\n\n\t\tif (this._finishedCallback) {\n\t\t\tlet args = [error, this._results];\n\t\t\tif (this._incrementalMode) {\n\t\t\t\targs.push(done);\n\t\t\t\targs.push(page);\n\t\t\t}\n\t\t\tthis._finishedCallback.apply(this, args);\n\t\t}\n\t}\n\n\t/**\n\t * Load a single page of data, starting at a specific offset.\n\t *\n\t * @param {Pagination} [page] the page to load\n\t * @returns {void}\n\t * @private\n\t */\n\tloadData(page) {\n\t\tconst auth = this.authBuilder;\n\t\tconst q = this._queue;\n\t\tlet pagination = page instanceof Pagination ? page : new Pagination();\n\t\tconst queryFilter = new DatumFilter(this.filter);\n\t\tqueryFilter.withoutTotalResultsCount =\n\t\t\t(this._includeTotalResultsCount || q) && pagination.offset === 0 ? false : true;\n\n\t\tlet url = this._readingsMode\n\t\t\t? this.urlHelper.datumReadingUrl(\n\t\t\t\t\tqueryFilter,\n\t\t\t\t\tDatumReadingTypes.Difference,\n\t\t\t\t\tundefined,\n\t\t\t\t\tundefined,\n\t\t\t\t\tpagination\n\t\t\t  )\n\t\t\t: this.urlHelper.listDatumUrl(queryFilter, undefined, pagination);\n\t\tif (this._urlParameters) {\n\t\t\tlet queryParams = urlQuery.urlQueryEncode(this._urlParameters);\n\t\t\tif (queryParams) {\n\t\t\t\turl += \"&\" + queryParams;\n\t\t\t}\n\t\t}\n\t\tconst reqUrl = this._proxyUrl ? url.replace(/^[^:]+:\\/\\/[^/]+/, this._proxyUrl) : url;\n\t\tconst jsonClient = this.client();\n\t\tconst req = jsonClient(reqUrl)\n\t\t\t.on(\"beforesend\", request => {\n\t\t\t\tif (auth && auth.signingKeyValid) {\n\t\t\t\t\tauth.reset()\n\t\t\t\t\t\t.snDate(true)\n\t\t\t\t\t\t.url(url, true);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.X_SN_DATE, auth.requestDateHeaderValue);\n\t\t\t\t\trequest.setRequestHeader(HttpHeaders.AUTHORIZATION, auth.buildWithSavedKey());\n\t\t\t\t}\n\t\t\t})\n\t\t\t.on(\"load\", json => {\n\t\t\t\tlet dataArray = datumExtractor(json);\n\t\t\t\tif (dataArray === undefined) {\n\t\t\t\t\tlog.debug(\"No data available for %s\", reqUrl);\n\t\t\t\t\tthis.handleResults();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst incMode = this._incrementalMode;\n\t\t\t\tconst nextOffset = offsetExtractor(json, pagination);\n\t\t\t\tconst totalResults = json.data ? json.data.totalResults : null;\n\n\t\t\t\tif (this._results === undefined || incMode) {\n\t\t\t\t\tthis._results = dataArray;\n\n\t\t\t\t\t// discover page size, if pagination does not already have one\n\t\t\t\t\tif (pagination.max < 1) {\n\t\t\t\t\t\tconst max = pageSizeExtractor(json);\n\t\t\t\t\t\tif (max > 0) {\n\t\t\t\t\t\t\tpagination = new Pagination(max, pagination.offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incMode) {\n\t\t\t\t\t\tthis.handleResults(undefined, nextOffset < 1, pagination);\n\t\t\t\t\t}\n\t\t\t\t} else if (!q) {\n\t\t\t\t\tthis._results = this._results.concat(dataArray);\n\t\t\t\t}\n\n\t\t\t\t// see if we need to load more results\n\t\t\t\tif (nextOffset > 0 || (q && pagination.offset > 0)) {\n\t\t\t\t\tif (q) {\n\t\t\t\t\t\tif (totalResults > 0) {\n\t\t\t\t\t\t\t// parallel mode with first page results; queue all remaining pages\n\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\tlet pOffset = nextOffset;\n\t\t\t\t\t\t\t\tpOffset < totalResults;\n\t\t\t\t\t\t\t\tpOffset += pagination.max\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.loadData(pagination.withOffset(pOffset));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tq.awaitAll((error, allResults) => {\n\t\t\t\t\t\t\t\tif (!error) {\n\t\t\t\t\t\t\t\t\tallResults\n\t\t\t\t\t\t\t\t\t\t.map(function(qJson) {\n\t\t\t\t\t\t\t\t\t\t\treturn datumExtractor(qJson) || [];\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t.forEach(resultArray => {\n\t\t\t\t\t\t\t\t\t\t\tthis._results = this._results.concat(resultArray);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.handleResults(error !== null ? error : undefined, true);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.loadData(pagination.withOffset(nextOffset));\n\t\t\t\t\t}\n\t\t\t\t} else if (!incMode) {\n\t\t\t\t\tthis.handleResults(undefined, true);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.on(\"error\", error => {\n\t\t\t\tlog.error(\"Error requesting data for %s: %s\", reqUrl, error);\n\t\t\t\tthis.handleResults(new Error(`Error requesting data for ${reqUrl}: ${error}`));\n\t\t\t});\n\t\tif (q && pagination.offset > 0) {\n\t\t\tq.defer(req.get, null);\n\t\t} else {\n\t\t\treq.get();\n\t\t}\n\t}\n}\n\n/**\n * Extract the datum list from the returned data.\n *\n * @param {object} json the JSON results to extract from\n * @returns {Datum[]} the extracted data\n * @private\n */\nfunction datumExtractor(json) {\n\tif (\n\t\tjson.success !== true ||\n\t\tjson.data === undefined ||\n\t\tArray.isArray(json.data.results) !== true\n\t) {\n\t\treturn undefined;\n\t}\n\treturn json.data.results;\n}\n\n/**\n * Extract the page size from the returned data.\n *\n * @param {object} json the JSON results to extract from\n * @returns {number} the extracted page size\n * @private\n */\nfunction pageSizeExtractor(json) {\n\tconst data = json.data;\n\treturn data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t? data.returnedResultCount\n\t\t: 0;\n}\n\n/**\n * Extract the \"next\" offset to use based on the returned data.\n *\n * If `page` is supplied, then pagination will be based on `page.max` and will continue\n * until less than that many results are returned. If `page` is not supplied, then\n * pagination will be based on `data.returnedResultCount` and will continue until\n * `data.totalResults` has been returned.\n *\n * @param {object} json the JSON results to extract from\n * @param {Pagination} [page] the incremental mode page\n * @returns {number} the extracted offset, or `0` if no more pages to return\n * @private\n */\nfunction offsetExtractor(json, page) {\n\tconst data = json.data;\n\tif (page && page.max) {\n\t\t// don't bother with totalResults; just keep going unless returnedResultCount < page.max\n\t\treturn data.returnedResultCount < page.max ? 0 : data.startingOffset + page.max;\n\t}\n\treturn data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t? data.returnedResultCount + data.startingOffset\n\t\t: 0;\n}\n\nexport default DatumLoader;\n","import { queue } from \"d3-queue\";\n\n/**\n * Interface for classes that can be used to load data for {@link MultiLoader}.\n *\n * @interface Loader\n */\n\n/**\n * The loader callback function.\n *\n * @callback Loader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Object} data the result data\n */\n\n/**\n * Load data asynchronously with a callback.\n *\n * @function\n * @name Loader#load\n * @param {Loader~dataCallback} callback the callback to invoke with the results\n * @returns {Loader} the loader object\n */\n\n/**\n * The data callback function.\n *\n * @callback MultiLoader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Object[]} data the result data from all loaders\n */\n\n/**\n * Load data from multiple {@link Loader} objects, invoking a callback function\n * after all data has been loaded. Call {@link MultiLoader#load} to start loading the data.\n *\n * The {@link DatumLoader} class conforms to the {@link Loader} interface, so can be used to\n * load arrays of {@link Datum} objects based on search criteria.\n *\n * @example\n * const filter1 = new DatumFilter();\n * filter1.nodeId = 123;\n * // configure other filter settings here...\n *\n * const filter2 = new DatumFilter();\n * filter2.nodeId = 234;\n * // configure other filter settings here\n *\n * const urlHelper = new NodeDatumUrlHelper();\n *\n * new MultiLoader([\n *   new DatumLoader(urlHelper, filter1),\n *   new DatumLoader(urlHelper, filter2),\n * ]).load((error, results) => {\n *   // results is a 2-element array of Datum arrays\n * });\n *\n * @version 1.1.0\n */\nclass MultiLoader {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {Loader[]} loaders - array of loader objects\n\t */\n\tconstructor(loaders) {\n\t\tObject.defineProperties(this, {\n\t\t\t/**\n\t\t\t * The class version.\n\t\t\t *\n\t\t\t * @memberof MultiLoader\n\t\t\t * @readonly\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\tversion: { value: \"1.1.0\" }\n\t\t});\n\n\t\t/**\n\t\t * @type {Loader[]}\n\t\t * @private\n\t\t */\n\t\tthis._loaders = loaders;\n\n\t\t/**\n\t\t * @type {MultiLoader~dataCallback}\n\t\t * @private\n\t\t */\n\t\tthis._finishedCallback = undefined;\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._concurrency = Infinity;\n\t}\n\n\t/**\n\t * Get or set the concurrency limit to use for requets.\n\t *\n\t * A default, infinite concurrency queue will be used by default.\n\t *\n\t * @param {number} [value] the concurrency level to use, or `Infinity` for no limit\n\t * @returns {number|MultiLoader} when used as a getter, the current concurrency value, otherwise this object\n\t * @since 1.1.0\n\t */\n\tconcurrency(value) {\n\t\tif (value === undefined) {\n\t\t\treturn this._concurrency;\n\t\t}\n\t\tvar n = Number(value);\n\t\tif (!isNaN(value) && n > 0) {\n\t\t\tthis._concurrency = n;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Asynchronously load the data.\n\t *\n\t * This method calls {@link MultiLoader#load} to perform the actual work.\n\t *\n\t * @returns {Promise<Object[]>} the result promise\n\t */\n\tfetch() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.load((error, results) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Initiate loading the data. This will call {@link Loader#load} on each\n\t * supplied loader, in parallel. As an alternative to configuring the callback function via\n\t * the {@link MultiLoader#callback} method, a callback function can be passed as an argument\n\t * to this function. This allows this function to be passed to `queue.defer`, for example.\n\t *\n\t * @param {MultiLoader~dataCallback} [callback] a callback function to use; either this argument must be provided\n\t *                              or the function must have already been configured via  {@link MultiLoader#callback}\n\t * @returns {MultiLoader} this object\n\t */\n\tload(callback) {\n\t\t// to support queue use, allow callback to be passed directly to this function\n\t\tif (typeof callback === \"function\") {\n\t\t\tthis._finishedCallback = callback;\n\t\t}\n\t\tconst q = queue(this._concurrency);\n\t\tthis._loaders.forEach(loader => {\n\t\t\t// queue.defer will invoke the callback with a `null` `this` object, so `e.load.bind` here\n\t\t\tq.defer(loader.load.bind(loader));\n\t\t});\n\t\tq.awaitAll((error, results) => {\n\t\t\tif (this._finishedCallback) {\n\t\t\t\tthis._finishedCallback.call(this, error, results);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the callback function, invoked after all data has been loaded. The callback\n\t * function will be passed two arguments: an error and the results as an array of results\n\t * from each configured {@link Loader}.\n\t *\n\t * @param {MultiLoader~dataCallback} [value] the callback function to use\n\t * @returns  {MultiLoader~dataCallback|MultiLoader} when used as a getter, the current callback function, otherwise this object\n\t */\n\tcallback(value) {\n\t\tif (!value) {\n\t\t\treturn this._finishedCallback;\n\t\t}\n\t\tif (typeof value === \"function\") {\n\t\t\tthis._finishedCallback = value;\n\t\t}\n\t\treturn this;\n\t}\n}\n\nexport default MultiLoader;\n"],"names":["JsonClientSupport","authBuilder","jsonClient","json","value","Promise","resolve","reject","load","error","results","callback","Error","DatumRangeFinder","urlHelpers","Object","defineProperties","version","_helpers","Array","isArray","NodeDatumUrlHelper","q","queue","client","auth","urlHelper","url","reportableIntervalUrl","req","on","request","signingKeyValid","reset","snDate","setRequestHeader","HttpHeaders","X_SN_DATE","requestDateHeaderValue","AUTHORIZATION","buildWithSavedKey","defer","get","awaitAll","log","intervalObj","extractReportableInterval","startDateMillis","undefined","sDate","Date","endDateMillis","eDate","result","i","repInterval","length","data","endDate","debug","nodeId","sourceIds","join","startDate","DatumSourceFinder","datumFilter","DatumFilter","requestKeys","addRequest","key","push","filter","nodeIds","metadataFilter","availableSourcesUrl","oneFilter","len","pair","indexOf","sourceId","DatumLoader","publicQuery","withoutTotalResultsCount","_pageSize","_includeTotalResultsCount","_finishedCallback","_urlParameters","_incrementalMode","_readingsMode","_proxyUrl","_concurrency","_queue","_state","_results","isNaN","Number","Infinity","loadData","Pagination","done","page","args","apply","pagination","queryFilter","offset","datumReadingUrl","DatumReadingTypes","Difference","listDatumUrl","queryParams","urlQuery","urlQueryEncode","reqUrl","replace","dataArray","datumExtractor","handleResults","incMode","nextOffset","offsetExtractor","totalResults","max","pageSizeExtractor","concat","pOffset","withOffset","allResults","map","qJson","forEach","resultArray","success","returnedResultCount","startingOffset","MultiLoader","loaders","_loaders","n","loader","bind","call"],"mappings":"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"}