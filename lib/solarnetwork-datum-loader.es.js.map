{"version":3,"file":"solarnetwork-datum-loader.es.js","sources":["../src/jsonClientSupport.js","../src/datumRangeFinder.js","../src/datumLoader.js","../src/multiLoader.js"],"sourcesContent":["import { json } from 'd3-request';\n\n/**\n * The data callback function.\n * \n * @callback JsonClientSupport~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {*} data the result data\n */\n\n/**\n * An abstract class with customizable JSON client support.\n * \n * @abstract\n */\nclass JsonClientSupport {\n\n    /**\n\t * Constructor.\n\t * \n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried\n\t */\n    constructor(authBuilder) {\n\n        /**\n         * An authorization builder to use to make authenticated HTTP requests.\n         * @type {AuthorizationV2Builder}\n         * @protected\n         */\n\t\tthis.authBuilder = authBuilder;\n        \n        \n        /**\n         * The JSON client.\n         * @private\n         */\n        this.jsonClient = json;\n    }\n\n\t/**\n\t * Get or set a JSON HTTP client function to use.\n     * \n     * The function must be compatible with `d3.json` and defaults to that. This provides a way\n     * to integrate a different HTTP client if needed, for example a mock implementation in tests.\n\t *\n\t * @param {function} [value] the JSON client function, compatible with `d3.json`\n\t * @returns {function|DatumSourceFinder} when used as a getter, the JSON client function, otherwise this object\n\t */\n\tclient(value) {\n        if ( !value ) return this.jsonClient;\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis.jsonClient = value;\n\t\t}\n\t\treturn this;\n    }\n\n    /**\n     * Asynchronously load the data.\n     * \n     * This method calls {@link JsonClientSupport#load} to perform the actual work.\n     * \n     * @returns {Promise<*>} the result promise\n     */\n    fetch() {\n        return new Promise((resolve, reject) => {\n            this.load((error, results) => {\n                if ( error ) {\n                    reject(error);\n                } else {\n                    resolve(results);\n                }\n            });\n        });\n    }\n\n    /**\n     * Asynchronously load the data using a callback.\n     * \n     * Extending classes must override this method to provide a useful implementation.\n     * \n     * @abstract\n     * @param {JsonClientSupport~dataCallback} callback the callback function to invoke\n     * @returns {void}\n     */\n    load(callback) {\n        callback(new Error('Abstract method must be implemented by subclass.'));\n    }\n}\n\nexport default JsonClientSupport;\n","import { queue } from 'd3-queue';\nimport {\n\tHttpHeaders,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n} from 'solarnetwork-api-core';\n\nimport JsonClientSupport from './jsonClientSupport';\n\n/**\n * @typedef {Object} DatumRange\n * @property {string} timeZone the local time zone of the node\n * @property {number} startDateMillis the start of the time range, in milliseconds since the epoch\n * @property {number} endDateMillis the end of the time range, in milliseconds since the epoch\n * @property {Date} sDate the start of the time range\n * @property {Date} eDate the end of the time range\n */\n\n/**\n * The data callback function.\n * \n * @callback DatumRangeFinder~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {DatumRange} data the result data\n */\n\n/**\n * Class to find the available datum date range for a set of node datum URL helpers.\n * \n * This is useful when generating reports or charts for a set of SolarNode datum streams,\n * so the overall start/end dates can be determined before requesting the actual data.\n * It returns an object starting and ending date related properties, for example:\n * \n * ```\n * {\n *   \"timeZone\":        \"Pacific/Auckland\",\n *   \"sDate\":           Date(1248668709972),\n *   \"startDate\":       \"2009-07-27 16:25\",\n *   \"startDateMillis\": 1248668709972,\n *   \"eDate\":           Date(1379824746781),\n *   \"endDate\":         \"2013-09-22 16:39\",\n *   \"endDateMillis\":   1379824746781\n * }\n * ```\n * \n * @example\n * // the simple case, for just one SolarNode\n * const urlHelper = new NodeDatumUrlHelper();\n * urlHelper.publicQuery = true;\n * urlHelper.nodeId = 123;\n * urlHelper.sourceIds = ['a', 'b'];\n * const range = await new DatumRangeFinder(urlHelper).fetch();\n * \n * @example\n * // more complex case, for multiple SolarNode / source ID combinations\n * const urlHelper2 = new NodeDatumUrlHelper();\n * urlHelper2.publicQuery = true;\n * urlHelper2.nodeId = 234;\n * urlHelper2.sourceId = 'c';\n * const range2 = await new DatumRangeFinder([urlHelper, urlHelper2]).fetch();\n * \n * @example\n * // with authentication; note the authentication must be valid for all SolarNodes!\n * const auth = new AuthorizationV2Builder('my-token');\n * auth.saveSigningKey('secret');\n * urlHelper.publicQuery = false;\n * urlHelper2.publicQuery = false;\n * const range3 = await new DatumRangeFinder([urlHelper, urlHelper2], auth).fetch();\n */\nclass DatumRangeFinder extends JsonClientSupport {\n    \n    /**\n     * Constructor.\n     * \n     * @param {NodeDatumUrlHelper|NodeDatumUrlHelper[]} urlHelpers the helper(s) to find the avaialble data range for\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried\n     */\n    constructor(urlHelpers, authBuilder) {\n        super(authBuilder);\n        Object.defineProperties(this, {\n            /**\n             * The class version.\n             * \n             * @memberof DatumRangeFinder\n             * @readonly\n             * @type {string}\n             */\n            version: { value: '1.0.0' }\n        });\n\n        /**\n         * @type {NodeDatumUrlHelper[]}\n         * @private\n         */\n        this._helpers = Array.isArray(urlHelpers) ? urlHelpers : urlHelpers ? [urlHelpers] : [new NodeDatumUrlHelper()];\n    }\n\n    /**\n     * Asynchronously find the available datum range using a callback.\n     * \n     * @param {DatumRangeFinder~dataCallback} callback the callback function to invoke\n     * @returns {void}\n     */\n    load(callback) {\n        const q = queue();\n        const jsonClient = this.client();\n        const auth = this.authBuilder;\n        for ( const urlHelper of this._helpers ) {\n            const url = urlHelper.reportableIntervalUrl();\n            const req = jsonClient(url);\n            if ( auth ) {\n                req.on('beforesend', (request) => {\n                    auth.reset().snDate(true).url(url);\n                    request.setRequestHeader(HttpHeaders.X_SN_DATE, auth.requestDateHeaderValue);\n                    request.setRequestHeader(HttpHeaders.AUTHORIZATION, auth.buildWithSavedKey());\n                });\n            }\n            q.defer(req.get, null);\n\t\t}\n        q.awaitAll((error, results) => {\n            if ( error ) {\n                log.error('Error requesting available data range: %s', error);\n                if ( typeof callback === 'function' ) {\n                    callback(error);\n                }\n                return;\n            }\n            var intervalObj = extractReportableInterval(results);\n            if ( intervalObj.startDateMillis !== undefined ) {\n                intervalObj.sDate = new Date(intervalObj.startDateMillis);\n            }\n            if ( intervalObj.endDateMillis !== undefined ) {\n                intervalObj.eDate = new Date(intervalObj.endDateMillis);\n            }\n    \n            if ( typeof callback === 'function' ) {\n                callback(null, intervalObj);\n            }\n        });\n    }\n\n}\n\nfunction extractReportableInterval(results) {\n    var result,\n        i = 0,\n        repInterval;\n    for ( i = 0; i < results.length; i += 1 ) {\n        repInterval = results[i];\n        if ( repInterval.data === undefined || repInterval.data.endDate === undefined ) {\n            log.debug('No data available for %s sources %s',\n                this._helpers[i].nodeId,\n                this._helpers[i].sourceIds.join(','));\n            continue;\n        }\n        repInterval = repInterval.data;\n        if ( result === undefined ) {\n            result = repInterval;\n        } else {\n            // merge start/end dates\n            // note we don't copy the time zone... this breaks when the tz are different!\n            if ( repInterval.endDateMillis > result.endDateMillis ) {\n                result.endDateMillis = repInterval.endDateMillis;\n                result.endDate = repInterval.endDate;\n            }\n            if ( repInterval.startDateMillis < result.startDateMillis ) {\n                result.startDateMillis = repInterval.startDateMillis;\n                result.startDate = repInterval.startDate;\n            }\n        }\n    }\n    return result;\n}\n\nexport default DatumRangeFinder;\n","import {\n\tDatumFilter,\n\tHttpHeaders,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n\tPagination,\n\turlQuery,\n} from 'solarnetwork-api-core';\n\nimport JsonClientSupport from './jsonClientSupport';\n\n/**\n * @typedef {Object} Datum\n * @property {string} created the datum date\n * @property {string} sourceId the control ID\n */\n\n/**\n * The data callback function.\n * \n * @callback DatumLoader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Datum[]} data the result data\n * @param {boolean} [done] in incremental mode, will be `true` when invoked on the *last* page of data\n * @param {Pagination} [page] in incremental mode, the page associated with the data\n */\n\n/**\n * Load data for a set of source IDs, date range, and aggregate level using the `listDatumUrl()` endpoint\n * of `NodeDatumUrlHelperMixin`.\n * \n * This object is designed to be used once per query. After creating the object and configuring an\n * asynchronous callback function with {@link DatumLoader#callback}, call {@link DatumLoader#load}\n * to startloading the data. The callback function will be called once all data has been loaded. The\n * callback function can also be passed as an argument to the {@link DatumLoader#load} method directly.\n * \n * @implements {Loader}\n * @example\n * const filter = new DatumFilter();\n * filter.nodeId = 123;\n * // configure other filter settings here...\n * \n * const urlHelper = new NodeDatumUrlHelper();\n * \n * new DatumLoader(urlHelper, filter).load((error, results) => {\n *   // results is an array of Datum objects\n * });\n */\nclass DatumLoader extends JsonClientSupport {\n\n\t/**\n\t * Constructor.\n\t * \n     * @param {NodeDatumUrlHelperMixin} urlHelper a URL helper for accessing node datum via SolarQuery\n\t * @param {DatumFilter} filter the filter parameters to use\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried\n\t */\n    constructor(urlHelper, filter, authBuilder) {\n\t\tsuper(authBuilder);\n        Object.defineProperties(this, {\n                /**\n                 * The class version.\n                 * \n                 * @memberof DatumLoader\n                 * @readonly\n                 * @type {string}\n                 */\n                version: { value: '1.0.0' }\n\t\t});\n\n\t\t/** @type {NodeDatumUrlHelper} */\n\t\tthis.urlHelper = urlHelper || new NodeDatumUrlHelper();\n\n\t\t/** @type {DatumFilter} */\n\t\tthis.filter = filter || new DatumFilter({nodeIds:this.urlHelper.nodeIds});\n\n        /**\n\t\t * @type {DatumLoader~dataCallback}\n\t\t * @private\n\t\t */\n        this._finishedCallback = undefined;\n\n        /**\n\t\t * @type {object}\n\t\t * @private\n\t\t */\n\t\tthis._urlParameters = undefined;\n\t\t\n\t\t/**\n\t\t * When `true` then call the callback function for every page of data as it becomes available.\n\t\t * Otherwise the callback function will be invoked only after all data has been loaded.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._incrementalMode = false;\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._state = 0;\n\n\t\t/**\n\t\t * @type {Datum[]}\n\t\t * @private\n\t\t */\n\t\tthis._results = undefined;\n    }\n\n\t/**\n\t * Get or set the callback function, invoked after all data has been loaded. The callback\n\t * function will be passed two arguments: an error and the results. In incremental mode,\n\t * the callback will also be passed a boolean that will be `true` on that last page of data,\n\t * and a `Pagination` that details which page the callback represents.\n\t *\n\t * @param {DatumLoader~dataCallback} [value] the callback function to use\n\t * @returns  {DatumLoader~dataCallback|DatumLoader} when used as a getter, the current callback function, otherwise this object\n\t */\n\tcallback(value) {\n\t\tif ( !value ) { return this._finishedCallback; }\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis._finishedCallback = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set additional URL parameters. The parameters are set as object properties.\n\t * If a property value is an array, multiple parameters for that property will be added.\n\t *\n\t * @param {object} [value] the URL parameters to include with the JSON request\n\t * @returns {object|DatumLoader} when used as a getter, the URL parameters, otherwise this object\n\t */\n    parameters(value) {\n\t\tif ( !value ) return this._urlParameters;\n\t\tif ( typeof value === 'object' ) {\n\t\t\tthis._urlParameters = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set _incremental mode_ for loading the data.\n\t * \n\t * When incremental mode is enabled (set to `true`) then the callback function will be invoked\n\t * for _each result page_ that is loaded. The function will be passed a second `boolean` argument\n\t * that will be set to `true` only on the last page of result data, and a third Pagination`\n\t * object argument that details the starting offset of the page.\n\t * \n\t * When incremental mode is disabled (set to `false`, the default) then all result pages are\n\t * combined into a single array and the callback will be invoked just once.\n\t * \n\t * @param {boolean} [value] the incremental mode to set \n\t * @returns {boolean|DatumLoader} when used a a getter, the incremental mode; otherwise this object\n\t */\n\tincremental(value) {\n\t\tif ( value === undefined ) return this._incrementalMode;\n\t\tthis._incrementalMode = !!value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initiate loading the data.\n\t * \n\t * As an alternative to configuring the callback function via the {@link DatumLoader#callback}\n\t * method,a callback function can be passed as an argument to this function. That allows this\n\t * function to be passed to things like `queue.defer`, for example.\n\t *\n\t * @param {DatumLoader~dataCallback} [callback] a callback function to use; either this argument must be provided\n\t *                              or the function must have already been configured via {@link DatumLoader#callback}\n\t * @returns {DatumLoader} this object\n\t */\n\tload(callback) {\n\t\t// to support queue use, allow callback to be passed directly to this function\n\t\tif ( typeof callback === 'function' ) {\n\t\t\tthis._finishedCallback = callback;\n\t\t}\n\t\tthis._state = 1;\n\t\tthis.loadData();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the configured callback function.\n\t * \n\t * @param {Error} [error] an optional  error\n\t * @param {boolean} done `true` if there is no more data to load\n\t * @param {Pagination} [page] the incremental mode page\n\t * @returns {void}\n\t * @private\n\t */\n\thandleResults(error, done, page) {\n\t\tif ( done ) {\n\t\t\tthis._state = 2; // done\n\t\t}\n\n\t\tif ( this._finishedCallback ) {\n\t\t\tlet args = [error, this._results];\n\t\t\tif ( this._incrementalMode ) {\n\t\t\t\targs.push(done);\n\t\t\t\targs.push(page);\n\t\t\t}\n\t\t\tthis._finishedCallback.apply(this, args);\n\t\t}\n\t}\n\n\t/**\n\t * Load a single page of data, starting at a specific offset.\n\t * \n\t * @param {Pagination} [page] the page to load\n\t * @returns {void}\n\t * @private\n\t */\n\tloadData(page) {\n\t\tlet pagination = (page instanceof Pagination ? page : new Pagination());\n\t\tlet url = this.urlHelper.listDatumUrl(this.filter, undefined, pagination);\n\t\tif ( this._urlParameters ) {\n\t\t\tlet queryParams = urlQuery.urlQueryEncode(this._urlParameters);\n\t\t\tif ( queryParams ) {\n\t\t\t\turl += '&' + queryParams;\n\t\t\t}\n\t\t}\n\t\tconst authBuilder = this.authBuilder;\n\t\tconst jsonClient = this.client();\n\t\tjsonClient(url)\n\t\t\t.on('beforesend', (request) => {\n\t\t\t\tif ( !authBuilder ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tauthBuilder.reset().snDate(true).url(url);\n\t\t\t\trequest.setRequestHeader(HttpHeaders.X_SN_DATE, authBuilder.requestDateHeaderValue);\n\t\t\t\trequest.setRequestHeader(HttpHeaders.AUTHORIZATION, authBuilder.buildWithSavedKey());\n\t\t\t}).on('load', (json) => {\n\t\t\t\tlet dataArray = datumExtractor(json);\n\t\t\t\tif ( dataArray === undefined ) {\n\t\t\t\t\tlog.debug('No data available for %s', url);\n\t\t\t\t\tthis.handleResults();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst incMode = this._incrementalMode;\n\t\t\t\tconst nextOffset = offsetExtractor(json);\n\n\t\t\t\tif ( this._results === undefined || incMode ) {\n\t\t\t\t\tthis._results = dataArray;\n\t\t\t\t\t\n\t\t\t\t\t// discover page size, if pagination does not already have one\n\t\t\t\t\tif ( pagination.max < 1 ) {\n\t\t\t\t\t\tconst max = pageSizeExtractor(json);\n\t\t\t\t\t\tif ( max > 0 ) {\n\t\t\t\t\t\t\tpagination = new Pagination(max, pagination.offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( incMode ) {\n\t\t\t\t\t\tthis.handleResults(undefined, nextOffset < 1, pagination);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._results = this._results.concat(dataArray);\n\t\t\t\t}\n\n\t\t\t\t// see if we need to load more results\n\t\t\t\tif ( nextOffset > 0 ) {\n\t\t\t\t\tthis.loadData(pagination.withOffset(nextOffset));\n\t\t\t\t} else if ( !incMode ) {\n\t\t\t\t\tthis.handleResults(undefined, true);\n\t\t\t\t}\n\t\t\t}).on('error', (error) => {\n\t\t\t\tlog.error('Error requesting data for %s: %s', url, error);\n\t\t\t\tthis.handleResults(new Error(`Error requesting data for ${url}: ${error}`));\n\t\t\t})\n\t\t\t.get();\n\t}\n\n}\n\n/**\n * Extract the datum list from the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {Datum[]} the extracted data\n * @private\n */\n\nfunction datumExtractor(json) {\n\tif ( json.success !== true || json.data === undefined || Array.isArray(json.data.results) !== true ) {\n\t\treturn undefined;\n\t}\n\treturn json.data.results;\n}\n\n/**\n * Extract the page size from the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {number} the extracted page size\n * @private\n */\nfunction pageSizeExtractor(json) {\n\tconst data = json.data;\n\treturn (data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t\t? data.returnedResultCount\n\t\t\t: 0);\n}\n\n/**\n * Extract the \"next\" offset to use based on the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {number} the extracted offset\n * @private\n */\nfunction offsetExtractor(json) {\n\tconst data = json.data;\n\treturn (data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t\t? (data.returnedResultCount + data.startingOffset)\n\t\t\t: 0);\n}\n\nexport default DatumLoader;\n","import { queue } from 'd3-queue';\n\n/**\n * Interface for classes that can be used to load data for {@link MultiLoader}.\n *\n * @interface Loader\n */\n\n /**\n * The loader callback function.\n * \n * @callback Loader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Object} data the result data\n */\n\n/**\n * Load data asynchronously with a callback.\n *\n * @function\n * @name Loader#load\n * @param {Loader~dataCallback} callback the callback to invoke with the results\n * @returns {Loader} the loader object\n */\n\n/**\n * The data callback function.\n * \n * @callback MultiLoader~dataCallback\n * @param {Error} [error] an error if a failure occurred\n * @param {Object[]} data the result data from all loaders\n */\n\n/**\n * Load data from multiple {@link Loader} objects, invoking a callback function\n * after all data has been loaded. Call {@link MultiLoader#load} to start loading the data.\n * \n * The {@link DatumLoader} class conforms to the {@link Loader} interface, so can be used to\n * load arrays of {@link Datum} objects based on search criteria.\n * \n * @example\n * const filter1 = new DatumFilter();\n * filter1.nodeId = 123;\n * // configure other filter settings here...\n * \n * const filter2 = new DatumFilter();\n * filter2.nodeId = 234;\n * // configure other filter settings here\n * \n * const urlHelper = new NodeDatumUrlHelper();\n * \n * new MultiLoader([\n *   new DatumLoader(urlHelper, filter1),\n *   new DatumLoader(urlHelper, filter2),\n * ]).load((error, results) => {\n *   // results is a 2-element array of Datum arrays\n * });\n */\nclass MultiLoader {\n    \n\t/**\n\t * Constructor.\n\t *\n\t * @param {Loader[]} loaders - array of loader objects\n\t */\n    constructor(loaders) {\n        Object.defineProperties(this, {\n                /**\n                 * The class version.\n                 * \n                 * @memberof MultiLoader\n                 * @readonly\n                 * @type {string}\n                 */\n                version: { value: '1.0.0' }\n\t\t});\n\n\t\t/**\n\t\t * @type {Loader[]}\n\t\t * @private\n\t\t */\n\t\tthis._loaders = loaders;\n\t\t\n\t\t/**\n\t\t * @type {MultiLoader~dataCallback}\n\t\t * @private\n\t\t */\n\t\tthis._finishedCallback = undefined;\n\t\t\n    }\n\n    /**\n     * Asynchronously load the data.\n     * \n     * This method calls {@link MultiLoader#load} to perform the actual work.\n     * \n     * @returns {Promise<Object[]>} the result promise\n     */\n    fetch() {\n        return new Promise((resolve, reject) => {\n            this.load((error, results) => {\n                if ( error ) {\n                    reject(error);\n                } else {\n                    resolve(results);\n                }\n            });\n        });\n    }\n\n\t/**\n\t * Initiate loading the data. This will call {@link Loader#load} on each\n\t * supplied loader, in parallel. As an alternative to configuring the callback function via\n\t * the {@link MultiLoader#callback} method, a callback function can be passed as an argument\n\t * to this function. This allows this function to be passed to `queue.defer`, for example.\n\t *\n\t * @param {MultiLoader~dataCallback} [callback] a callback function to use; either this argument must be provided\n\t *                              or the function must have already been configured via  {@link MultiLoader#callback}\n\t * @returns {MultiLoader} this object\n\t */\n\tload(callback) {\n\t\t// to support queue use, allow callback to be passed directly to this function\n\t\tif ( typeof callback === 'function' ) {\n\t\t\tthis._finishedCallback = callback;\n\t\t}\n\t\tconst q = queue();\n\t\tthis._loaders.forEach((e) => {\n\t\t\t// queue.defer will invoke the callback with a `null` `this` object, so can't pass `e.load` directly here\n\t\t\tq.defer((cb) => {\n\t\t\t\te.load(cb);\n\t\t\t});\n\t\t});\n\t\tq.awaitAll((error, results) => {\n\t\t\tif ( this._finishedCallback ) {\n\t\t\t\tthis._finishedCallback.call(this, error, results);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the callback function, invoked after all data has been loaded. The callback\n\t * function will be passed two arguments: an error and the results as an array of results\n\t * from each configured {@link Loader}.\n\t *\n\t * @param {MultiLoader~dataCallback} [value] the callback function to use\n\t * @returns  {MultiLoader~dataCallback|MultiLoader} when used as a getter, the current callback function, otherwise this object\n\t */\n\tcallback(value) {\n\t\tif ( !value ) { return this._finishedCallback; }\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis._finishedCallback = value;\n\t\t}\n\t\treturn this;\n\t}\n\n}\n\nexport default MultiLoader;\n"],"names":["JsonClientSupport","authBuilder","jsonClient","json","value","Promise","resolve","reject","load","error","results","callback","Error","DatumRangeFinder","urlHelpers","defineProperties","_helpers","Array","isArray","NodeDatumUrlHelper","q","queue","client","auth","urlHelper","url","reportableIntervalUrl","req","on","request","reset","snDate","setRequestHeader","HttpHeaders","X_SN_DATE","requestDateHeaderValue","AUTHORIZATION","buildWithSavedKey","defer","get","awaitAll","intervalObj","extractReportableInterval","startDateMillis","undefined","sDate","Date","endDateMillis","eDate","result","i","repInterval","length","data","endDate","debug","nodeId","sourceIds","join","startDate","DatumLoader","filter","DatumFilter","nodeIds","_finishedCallback","_urlParameters","_incrementalMode","_state","_results","loadData","done","page","args","push","apply","pagination","Pagination","listDatumUrl","queryParams","urlQuery","urlQueryEncode","dataArray","datumExtractor","handleResults","incMode","nextOffset","offsetExtractor","max","pageSizeExtractor","offset","concat","withOffset","success","returnedResultCount","startingOffset","totalResults","MultiLoader","loaders","_loaders","forEach","e","cb","call"],"mappings":"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"}