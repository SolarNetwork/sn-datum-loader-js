{"version":3,"file":"solarnetwork-datum-loader.es.js","sources":["../src/datumLoader.js"],"sourcesContent":["import { json } from 'd3-request';\nimport {\n\tDatumFilter,\n\tHttpHeaders,\n\tLogger as log,\n\tNodeDatumUrlHelper,\n\tPagination,\n\turlQuery,\n} from 'solarnetwork-api-core';\n\n/**\n * @typedef {Object} Datum\n * @property {string} created the datum date\n * @property {string} sourceId the control ID\n */\n\n/**\n * The data callback function.\n * \n * @callback DatumLoader~dataCallback\n * @param {Datum[]} data the result data\n * @param {boolean} [done] in incremental mode, will be `true` when invoked on the *last* page of data\n * @param {Pagination} [page] in incremental mode, the page associated with the data\n */\n\n/**\n * Load data for a set of source IDs, date range, and aggregate level using the `listDatumUrl()` endpoint\n * of `NodeDatumUrlHelperMixin`.\n * \n * This object is designed to be used once per query. After creating the object and configuring an\n * asynchronous callback function with {@link DatumLoader#callback}, call {@link DatumLoader#load}\n * to startloading the data. The callback function will be called once all data has been loaded. The\n * callback function can also be passed as an argument to the {@link DatumLoader#load} method directly.\n */\nclass DatumLoader {\n\n\t/**\n\t * Constructor.\n\t * \n     * @param {NodeDatumUrlHelperMixin} urlHelper a URL helper for accessing node datum via SolarQuery\n\t * @param {DatumFilter} filter the filter parameters to use\n\t * @param {AuthorizationV2Builder} [authBuilder] the auth builder to authenticate requests with; if not provided\n\t *                                               then only public data can be queried\n\t */\n    constructor(urlHelper, filter, authBuilder) {\n\n\t\t/** @type {NodeDatumUrlHelper} */\n\t\tthis.urlHelper = urlHelper || new NodeDatumUrlHelper();\n\n\t\t/** @type {DatumFilter} */\n\t\tthis.filter = filter || new DatumFilter({nodeIds:this.urlHelper.nodeIds});\n\n\t\t/** @type {AuthorizationV2Builder} */\n\t\tthis.authBuilder = authBuilder;\n\n        /**\n\t\t * @type {dataCallback}\n\t\t * @private\n\t\t */\n        this._finishedCallback = undefined;\n\n        /**\n\t\t * @type {object}\n\t\t * @private\n\t\t */\n\t\tthis._urlParameters = undefined;\n\t\t\n        /**\n\t\t * @type {json}\n\t\t * @private\n\t\t */\n\t\tthis.jsonClient = json;\n\t\t\n\t\t/**\n\t\t * When `true` then call the callback function for every page of data as it becomes available.\n\t\t * Otherwise the callback function will be invoked only after all data has been loaded.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tthis._incrementalMode = false;\n\n\t\t/**\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\tthis._state = 0;\n\n\t\t/**\n\t\t * @type {Datum[]}\n\t\t * @private\n\t\t */\n\t\tthis._results = undefined;\n    }\n\n\t/**\n\t * Get or set a JSON client function to use. The function must be compatible with `d3.json`\n\t * and defaults to that.\n\t *\n\t * @param {function} [value] the JSON client function, compatible with `d3.json`\n\t * @returns {function|DatumLoader} when used as a getter, the JSON client function, otherwise this object\n\t */\n\tclient(value) {\n        if ( !value ) return this.jsonClient;\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis.jsonClient = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set the callback function, invoked after all data has been loaded. The callback\n\t * function will be passed two arguments: an error and the results. In incremental mode,\n\t * the callback will also be passed a boolean that will be `true` on that last page of data,\n\t * and a `Pagination` that details which page the callback represents.\n\t *\n\t * @param {dataCallback} [value] the callback function to use\n\t * @returns  {dataCallback|DatumLoader} when used as a getter, the current callback function, otherwise this object\n\t */\n\tcallback(value) {\n\t\tif ( !value ) { return this._finishedCallback; }\n\t\tif ( typeof value === 'function' ) {\n\t\t\tthis._finishedCallback = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set additional URL parameters. The parameters are set as object properties.\n\t * If a property value is an array, multiple parameters for that property will be added.\n\t *\n\t * @param {object} [value] the URL parameters to include with the JSON request\n\t * @returns {object|DatumLoader} when used as a getter, the URL parameters, otherwise this object\n\t */\n    parameters(value) {\n\t\tif ( !value ) return this._urlParameters;\n\t\tif ( typeof value === 'object' ) {\n\t\t\tthis._urlParameters = value;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set _incremental mode_ for loading the data.\n\t * \n\t * When incremental mode is enabled (set to `true`) then the callback function will be invoked\n\t * for _each result page_ that is loaded. The function will be passed a second `boolean` argument\n\t * that will be set to `true` only on the last page of result data, and a third Pagination`\n\t * object argument that details the starting offset of the page.\n\t * \n\t * When incremental mode is disabled (set to `false`, the default) then all result pages are\n\t * combined into a single array and the callback will be invoked just once.\n\t * \n\t * @param {boolean} [value] the incremental mode to set \n\t * @returns {boolean|DatumLoader} when used a a getter, the incremental mode; otherwise this object\n\t */\n\tincremental(value) {\n\t\tif ( value === undefined ) return this._incrementalMode;\n\t\tthis._incrementalMode = !!value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Initiate loading the data.\n\t * \n\t * As an alternative to configuring the callback function via the {@link DatumLoader#callback}\n\t * method,a callback function can be passed as an argument to this function. That allows this\n\t * function to be passed to things like `queue.defer`, for example.\n\t *\n\t * @param {function} [callback] a callback function to use; either this argument must be provided\n\t *                              or the function must have already been configured via \n\t *                              {@link DatumLoader#callback}\n\t * @returns {DatumLoader} this object\n\t */\n\tload(callback) {\n\t\t// to support queue use, allow callback to be passed directly to this function\n\t\tif ( typeof callback === 'function' ) {\n\t\t\tthis._finishedCallback = callback;\n\t\t}\n\t\tthis._state = 1;\n\t\tthis.loadData();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the configured callback function.\n\t * \n\t * @param {Error} [error] an optional  error\n\t * @param {boolean} done `true` if there is no more data to load\n\t * @param {Pagination} [page] the incremental mode page\n\t * @returns {void}\n\t * @private\n\t */\n\thandleResults(error, done, page) {\n\t\tif ( done ) {\n\t\t\tthis._state = 2; // done\n\t\t}\n\n\t\tif ( this._finishedCallback ) {\n\t\t\tlet args = [error, this._results];\n\t\t\tif ( this._incrementalMode ) {\n\t\t\t\targs.push(done);\n\t\t\t\targs.push(page);\n\t\t\t}\n\t\t\tthis._finishedCallback.apply(this, args);\n\t\t}\n\t}\n\n\t/**\n\t * Load a single page of data, starting at a specific offset.\n\t * \n\t * @param {Pagination} [page] the page to load\n\t * @returns {void}\n\t * @private\n\t */\n\tloadData(page) {\n\t\tlet pagination = (page instanceof Pagination ? page : new Pagination());\n\t\tlet url = this.urlHelper.listDatumUrl(this.filter, undefined, pagination);\n\t\tif ( this._urlParameters ) {\n\t\t\tlet queryParams = urlQuery.urlQueryEncode(this._urlParameters);\n\t\t\tif ( queryParams ) {\n\t\t\t\turl += '&' + queryParams;\n\t\t\t}\n\t\t}\n\t\tconst authBuilder = this.authBuilder;\n\t\tthis.jsonClient(url)\n\t\t\t.on('beforesend', (request) => {\n\t\t\t\tif ( !authBuilder ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tauthBuilder.reset().snDate(true).url(url);\n\t\t\t\trequest.setRequestHeader(HttpHeaders.X_SN_DATE, authBuilder.requestDateHeaderValue);\n\t\t\t\trequest.setRequestHeader(HttpHeaders.AUTHORIZATION, authBuilder.buildWithSavedKey());\n\t\t\t}).on('load', (json) => {\n\t\t\t\tlet dataArray = datumExtractor(json);\n\t\t\t\tif ( dataArray === undefined ) {\n\t\t\t\t\tlog.debug('No data available for %s', url);\n\t\t\t\t\tthis.handleResults();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tconst incMode = this._incrementalMode;\n\t\t\t\tconst nextOffset = offsetExtractor(json);\n\n\t\t\t\tif ( this._results === undefined || incMode ) {\n\t\t\t\t\tthis._results = dataArray;\n\t\t\t\t\t\n\t\t\t\t\t// discover page size, if pagination does not already have one\n\t\t\t\t\tif ( pagination.max < 1 ) {\n\t\t\t\t\t\tconst max = pageSizeExtractor(json);\n\t\t\t\t\t\tif ( max > 0 ) {\n\t\t\t\t\t\t\tpagination = new Pagination(max, pagination.offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( incMode ) {\n\t\t\t\t\t\tthis.handleResults(undefined, nextOffset < 1, pagination);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._results = this._results.concat(dataArray);\n\t\t\t\t}\n\n\t\t\t\t// see if we need to load more results\n\t\t\t\tif ( nextOffset > 0 ) {\n\t\t\t\t\tthis.loadData(pagination.withOffset(nextOffset));\n\t\t\t\t} else if ( !incMode ) {\n\t\t\t\t\tthis.handleResults(undefined, true);\n\t\t\t\t}\n\t\t\t}).on('error', (error) => {\n\t\t\t\tlog.error('Error requesting data for %s: %s', url, error);\n\t\t\t\tthis.handleResults(new Error(`Error requesting data for ${url}: ${error}`));\n\t\t\t})\n\t\t\t.get();\n\t}\n\n}\n\n/**\n * Extract the datum list from the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {Datum[]} the extracted data\n * @private\n */\n\nfunction datumExtractor(json) {\n\tif ( json.success !== true || json.data === undefined || Array.isArray(json.data.results) !== true ) {\n\t\treturn undefined;\n\t}\n\treturn json.data.results;\n}\n\n/**\n * Extract the page size from the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {number} the extracted page size\n * @private\n */\nfunction pageSizeExtractor(json) {\n\tconst data = json.data;\n\treturn (data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t\t? data.returnedResultCount\n\t\t\t: 0);\n}\n\n/**\n * Extract the \"next\" offset to use based on the returned data.\n * \n * @param {object} json the JSON results to extract from\n * @returns {number} the extracted offset\n * @private\n */\nfunction offsetExtractor(json) {\n\tconst data = json.data;\n\treturn (data.returnedResultCount + data.startingOffset < data.totalResults\n\t\t\t? (data.returnedResultCount + data.startingOffset)\n\t\t\t: 0);\n}\n\nexport default DatumLoader;\n"],"names":["DatumLoader","urlHelper","filter","authBuilder","NodeDatumUrlHelper","DatumFilter","nodeIds","_finishedCallback","undefined","_urlParameters","jsonClient","json","_incrementalMode","_state","_results","value","callback","loadData","error","done","page","args","push","apply","pagination","Pagination","url","listDatumUrl","queryParams","urlQuery","urlQueryEncode","on","request","reset","snDate","setRequestHeader","HttpHeaders","X_SN_DATE","requestDateHeaderValue","AUTHORIZATION","buildWithSavedKey","dataArray","datumExtractor","debug","handleResults","incMode","nextOffset","offsetExtractor","max","pageSizeExtractor","offset","concat","withOffset","Error","get","success","data","Array","isArray","results","returnedResultCount","startingOffset","totalResults"],"mappings":"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"}